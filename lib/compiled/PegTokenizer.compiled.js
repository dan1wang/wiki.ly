module.exports = ( function () {

"use strict";
/*
 * Generated by WikiPEG
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;

  this.name     = "SyntaxError";
}

peg$subclass(peg$SyntaxError, Error);

function peg$Reference(value) {
  this.value = value;
}

peg$Reference.prototype = {
  get: function() {
    return this.value;
  },
  set: function(value) {
    this.value = value;
  }
};

function peg$DefaultTracer() {
  this.indentLevel = 0;
}

peg$DefaultTracer.prototype.trace = function(event) {
  var that = this;

  function log(event) {
    function repeat(string, n) {
      var result = "", i;

      for (i = 0; i < n; i++) {
        result += string;
      }

      return result;
    }

    function pad(string, length) {
      return string + repeat(" ", length - string.length);
    }

    function formatArgs(argMap) {
      var argParts = [];
      for (let argName in argMap) {
        if (argName === 'silence') {
          continue;
        }
        if (argName === 'boolParams') {
          argParts.push('0x' + argMap[argName].toString(16));
        } else {
          let displayName = argName.replace(/^param_/, '');
          if (typeof argMap[argName] === 'object' && argMap[argName].value !== undefined) {
            argParts.push(displayName + "=&" + JSON.stringify(argMap[argName].value));
          } else {
            argParts.push(displayName + "=" + argMap[argName]);
          }
        }
      }
      if (argParts.length) {
        return ' <' + argParts.join(', ') + '>';
      } else {
        return '';
      }
    }

    console.log(
      pad(
        event.location.start.line + ":" + event.location.start.column + "-"
        + event.location.end.line + ":" + event.location.end.column + " ",
        20
      )
      + pad(event.type, 10) + " "
      + repeat("  ", that.indentLevel) + event.rule
      + formatArgs(event.args)
    );
  }

  switch (event.type) {
    case "rule.enter":
      log(event);
      this.indentLevel++;
      break;

    case "rule.match":
      this.indentLevel--;
      log(event);
      break;

    case "rule.fail":
      this.indentLevel--;
      log(event);
      break;

    default:
      throw new Error("Invalid event type: " + event.type + ".");
  }
};

function peg$parse(input, options = {}) {
  var parser = this,
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$FAILED = {},
      peg$startRule = options.startRule || '(DEFAULT)',
      peg$result;

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description) {
    throw peg$buildException(
      null,
      [{ type: "other", description: description }],
      input.substring(peg$savedPos, peg$currPos),
      peg$computeLocation(peg$savedPos, peg$currPos)
    );
  }

  function error(message) {
    throw peg$buildException(
      message,
      null,
      input.substring(peg$savedPos, peg$currPos),
      peg$computeLocation(peg$savedPos, peg$currPos)
    );
  }

  var peg$posDetailsCache  = [{ line: 1, column: 1, seenCR: false }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [];

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
      p, ch;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column,
        seenCR: details.seenCR
      };

      while (p < pos) {
        ch = input.charAt(p);
        if (ch === "\n") {
          if (!details.seenCR) { details.line++; }
          details.column = 1;
          details.seenCR = false;
        } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
          details.line++;
          details.column = 1;
          details.seenCR = true;
        } else {
          details.column++;
          details.seenCR = false;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    if (endPos > input.length) {
      endPos--;
    }
    var startPosDetails = peg$computePosDetails(startPos),
      endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildException(message, expected, found, location) {
    function cleanupExpected(expected) {
      var i = 1;

      expected.sort(function(a, b) {
        if (a.description < b.description) {
          return -1;
        } else if (a.description > b.description) {
          return 1;
        } else {
          return 0;
        }
      });

      /*
       * This works because the bytecode generator guarantees that every
       * expectation object exists only once, so it's enough to use |===| instead
       * of deeper structural comparison.
       */
      while (i < expected.length) {
        if (expected[i - 1] === expected[i]) {
          expected.splice(i, 1);
        } else {
          i++;
        }
      }
    }

    function buildMessage(expected, found) {
      function stringEscape(s) {
        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

        /*
         * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
         * literal except for the closing quote character, backslash, carriage
         * return, line separator, paragraph separator, and line feed. Any character
         * may appear in the form of an escape sequence.
         *
         * For portability, we also escape all control and non-ASCII characters.
         * Note that "\0" and "\v" escape sequences are not used because JSHint does
         * not like the first and IE the second.
         */
        return s
          .replace(/\\/g,   '\\\\')       // backslash
          .replace(/"/g,    '\\"')        // closing double quote
          .replace(/\x08/g, '\\b')        // backspace
          .replace(/\t/g,   '\\t')        // horizontal tab
          .replace(/\n/g,   '\\n')        // line feed
          .replace(/\f/g,   '\\f')        // form feed
          .replace(/\r/g,   '\\r')        // carriage return
          .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
          .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
          .replace(/[\u0100-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
          .replace(/[\u1000-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
      }

      var expectedDescs = new Array(expected.length),
        expectedDesc, foundDesc, i;

      for (i = 0; i < expected.length; i++) {
        expectedDescs[i] = expected[i].description;
      }

      expectedDesc = expected.length > 1
        ? expectedDescs.slice(0, -1).join(", ")
        + " or "
        + expectedDescs[expected.length - 1]
        : expectedDescs[0];

      foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

      return "Expected " + expectedDesc + " but " + foundDesc + " found.";
    }

    if (expected !== null) {
      cleanupExpected(expected);
    }

    return new peg$SyntaxError(
      message !== null ? message : buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$buildParseException() {
    return peg$buildException(
      null,
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
    );
  }


  function peg$traceCall(parseFunc, name, argNames, args) {
    var argMap = {};
    for (let i = 0; i < args.length; i++) {
      argMap[argNames[i]] = args[i];
    }
    var startPos = peg$currPos;
    peg$tracer.trace({
      type:     "rule.enter",
      rule:     name,
      location: peg$computeLocation(startPos, startPos),
      args: argMap
    });
    var result = parseFunc.apply(null, args);
    if (result !== peg$FAILED) {
      peg$tracer.trace({
        type:     "rule.match",
        rule:     name,
        result:   result,
        location: peg$computeLocation(startPos, peg$currPos)
      });
    } else {
      peg$tracer.trace({
        type: "rule.fail",
        rule: name,
        location: peg$computeLocation(startPos, startPos)
      });
    }
    return result;
  }

  var peg$tracer = "tracer" in options ? options.tracer : new peg$DefaultTracer();

    const peg$cache = {};
    const visitCounts = new Uint8Array(input.length);

  // expectations
  var peg$c0 = {"type":"end","description":"end of input"};
  var peg$c1 = {"type":"other","description":"start"};
  var peg$c2 = {"type":"other","description":"table_start_tag"};
  var peg$c3 = {"type":"other","description":"url"};
  var peg$c4 = {"type":"other","description":"table_attributes"};
  var peg$c5 = {"type":"other","description":"generic_newline_attributes"};
  var peg$c6 = {"type":"other","description":"tplarg_or_template_or_bust"};
  var peg$c7 = {"type":"other","description":"extlink"};
  var peg$c8 = {"type":"other","description":"tlb"};
  var peg$c9 = {"type":"class","value":"[ \\t]","description":"[ \\t]"};
  var peg$c10 = {"type":"literal","value":"<!--","description":"\"<!--\""};
  var peg$c11 = {"type":"any","description":"any character"};
  var peg$c12 = {"type":"literal","value":"-->","description":"\"-->\""};
  var peg$c13 = {"type":"literal","value":"|","description":"\"|\""};
  var peg$c14 = {"type":"literal","value":"{{!}}","description":"\"{{!}}\""};
  var peg$c15 = {"type":"literal","value":"bitcoin:","description":"\"bitcoin:\""};
  var peg$c16 = {"type":"literal","value":"ftp://","description":"\"ftp://\""};
  var peg$c17 = {"type":"literal","value":"ftps://","description":"\"ftps://\""};
  var peg$c18 = {"type":"literal","value":"geo:","description":"\"geo:\""};
  var peg$c19 = {"type":"literal","value":"git://","description":"\"git://\""};
  var peg$c20 = {"type":"literal","value":"gopher://","description":"\"gopher://\""};
  var peg$c21 = {"type":"literal","value":"http://","description":"\"http://\""};
  var peg$c22 = {"type":"literal","value":"https://","description":"\"https://\""};
  var peg$c23 = {"type":"literal","value":"irc://","description":"\"irc://\""};
  var peg$c24 = {"type":"literal","value":"ircs://","description":"\"ircs://\""};
  var peg$c25 = {"type":"literal","value":"magnet:","description":"\"magnet:\""};
  var peg$c26 = {"type":"literal","value":"mailto:","description":"\"mailto:\""};
  var peg$c27 = {"type":"literal","value":"mms://","description":"\"mms://\""};
  var peg$c28 = {"type":"literal","value":"news:","description":"\"news:\""};
  var peg$c29 = {"type":"literal","value":"nntp://","description":"\"nntp://\""};
  var peg$c30 = {"type":"literal","value":"redis://","description":"\"redis://\""};
  var peg$c31 = {"type":"literal","value":"sftp://","description":"\"sftp://\""};
  var peg$c32 = {"type":"literal","value":"sip:","description":"\"sip:\""};
  var peg$c33 = {"type":"literal","value":"sips:","description":"\"sips:\""};
  var peg$c34 = {"type":"literal","value":"sms:","description":"\"sms:\""};
  var peg$c35 = {"type":"literal","value":"ssh://","description":"\"ssh://\""};
  var peg$c36 = {"type":"literal","value":"svn://","description":"\"svn://\""};
  var peg$c37 = {"type":"literal","value":"tel:","description":"\"tel:\""};
  var peg$c38 = {"type":"literal","value":"telnet://","description":"\"telnet://\""};
  var peg$c39 = {"type":"literal","value":"urn:","description":"\"urn:\""};
  var peg$c40 = {"type":"literal","value":"worldwind://","description":"\"worldwind://\""};
  var peg$c41 = {"type":"literal","value":"xmpp:","description":"\"xmpp:\""};
  var peg$c42 = {"type":"literal","value":"[","description":"\"[\""};
  var peg$c43 = {"type":"class","value":"[0-9A-Fa-f:.]","description":"[0-9A-Fa-f:.]"};
  var peg$c44 = {"type":"literal","value":"]","description":"\"]\""};
  var peg$c45 = {"type":"literal","value":"=","description":"\"=\""};
  var peg$c46 = {"type":"class","value":"[\\0/=>]","description":"[\\0/=>]"};
  var peg$c47 = {"type":"class","value":"[ \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]","description":"[ \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]"};
  var peg$c48 = {"type":"class","value":"[^\\r\\n]","description":"[^\\r\\n]"};
  var peg$c49 = {"type":"literal","value":"\n","description":"\"\\n\""};
  var peg$c50 = {"type":"literal","value":"\r\n","description":"\"\\r\\n\""};
  var peg$c51 = {"type":"literal","value":"{","description":"\"{\""};
  var peg$c52 = {"type":"literal","value":"&","description":"\"&\""};
  var peg$c53 = {"type":"class","value":"[#0-9a-zA-Z]","description":"[#0-9a-zA-Z]"};
  var peg$c54 = {"type":"literal","value":";","description":"\";\""};
  var peg$c55 = {"type":"class","value":"[\"'=]","description":"[\"'=]"};
  var peg$c56 = {"type":"class","value":"[^ \\t\\r\\n\\0/=><&{}\\-!|\\[]","description":"[^ \\t\\r\\n\\0/=><&{}\\-!|\\[]"};
  var peg$c57 = {"type":"literal","value":"'","description":"\"'\""};
  var peg$c58 = {"type":"literal","value":"\"","description":"\"\\\"\""};
  var peg$c59 = {"type":"literal","value":"/","description":"\"/\""};
  var peg$c60 = {"type":"class","value":"[^ \\t\\r\\n\\0/=><&{}\\-!|]","description":"[^ \\t\\r\\n\\0/=><&{}\\-!|]"};
  var peg$c61 = {"type":"class","value":"[ \\t\\n\\r\\x0c]","description":"[ \\t\\n\\r\\x0c]"};
  var peg$c62 = {"type":"class","value":"[^{|!=&[\\]'\"<>\\x00-\\x20\\x7F\\uFFFD \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]","description":"[^{|!=&[\\]'\"<>\\x00-\\x20\\x7F\\uFFFD \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]"};
  var peg$c63 = {"type":"class","value":"[{|!=]","description":"[{|!=]"};
  var peg$c64 = {"type":"class","value":"[^-'<~[{\\n\\r:;\\]}|!=]","description":"[^-'<~[{\\n\\r:;\\]}|!=]"};
  var peg$c65 = {"type":"literal","value":"[[","description":"\"[[\""};
  var peg$c66 = {"type":"class","value":"[ \\t\\n\\r\\0\\x0b]","description":"[ \\t\\n\\r\\0\\x0b]"};
  var peg$c67 = {"type":"literal","value":"#REDIRECT","description":"\"#REDIRECT\""};
  var peg$c68 = {"type":"literal","value":":","description":"\":\""};
  var peg$c69 = {"type":"literal","value":"<","description":"\"<\""};
  var peg$c70 = {"type":"literal","value":"{{","description":"\"{{\""};
  var peg$c71 = {"type":"class","value":"[^{}&<\\-!\\['\\r\\n|]","description":"[^{}&<\\-!\\['\\r\\n|]"};
  var peg$c72 = {"type":"class","value":"[{}&<\\-!\\[]","description":"[{}&<\\-!\\[]"};
  var peg$c73 = {"type":"class","value":"[^{}&<\\-!\\[\"\\r\\n|]","description":"[^{}&<\\-!\\[\"\\r\\n|]"};
  var peg$c74 = {"type":"class","value":"[^{}&<\\-!\\[ \\t\\n\\r\\x0c|]","description":"[^{}&<\\-!\\[ \\t\\n\\r\\x0c|]"};
  var peg$c75 = {"type":"class","value":"[^{}&<\\-|/'>]","description":"[^{}&<\\-|/'>]"};
  var peg$c76 = {"type":"class","value":"[{}&\\-|/]","description":"[{}&\\-|/]"};
  var peg$c77 = {"type":"class","value":"[^{}&<\\-|/\">]","description":"[^{}&<\\-|/\">]"};
  var peg$c78 = {"type":"class","value":"[^{}&<\\-|/ \\t\\n\\r\\x0c>]","description":"[^{}&<\\-|/ \\t\\n\\r\\x0c>]"};
  var peg$c79 = {"type":"literal","value":"__","description":"\"__\""};
  var peg$c80 = {"type":"literal","value":"-","description":"\"-\""};
  var peg$c81 = {"type":"literal","value":"''","description":"\"''\""};
  var peg$c82 = {"type":"literal","value":"----","description":"\"----\""};
  var peg$c83 = {"type":"literal","value":">","description":"\">\""};
  var peg$c84 = {"type":"literal","value":"{{{","description":"\"{{{\""};
  var peg$c85 = {"type":"literal","value":"}}}","description":"\"}}}\""};
  var peg$c86 = {"type":"literal","value":"}}","description":"\"}}\""};
  var peg$c87 = {"type":"literal","value":"]]","description":"\"]]\""};
  var peg$c88 = {"type":"class","value":"[^&[\\]{'\"<>\\x00-\\x20\\x7F\\uFFFD \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]","description":"[^&[\\]{'\"<>\\x00-\\x20\\x7F\\uFFFD \\u00A0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]"};
  var peg$c89 = {"type":"class","value":"[:{]","description":"[:{]"};
  var peg$c90 = {"type":"literal","value":"RFC","description":"\"RFC\""};
  var peg$c91 = {"type":"literal","value":"PMID","description":"\"PMID\""};
  var peg$c92 = {"type":"class","value":"[0-9]","description":"[0-9]"};
  var peg$c93 = {"type":"literal","value":"ISBN","description":"\"ISBN\""};
  var peg$c94 = {"type":"class","value":"[xX]","description":"[xX]"};
  var peg$c95 = {"type":"class","value":"[^'\"<~[{\\n\\r:;\\]}|!=]","description":"[^'\"<~[{\\n\\r:;\\]}|!=]"};
  var peg$c96 = {"type":"class","value":"[\\n\\r\\t ]","description":"[\\n\\r\\t ]"};
  var peg$c97 = {"type":"literal","value":"}","description":"\"}\""};
  var peg$c98 = {"type":"class","value":"[A-Za-z]","description":"[A-Za-z]"};
  var peg$c99 = {"type":"class","value":"[^<[{\\n\\r\\t|!\\]} &\\-]","description":"[^<[{\\n\\r\\t|!\\]} &\\-]"};
  var peg$c100 = {"type":"class","value":"[^'~[{:;|=]","description":"[^'~[{:;|=]"};
  var peg$c101 = {"type":"literal","value":"-{","description":"\"-{\""};
  var peg$c102 = {"type":"literal","value":"}-","description":"\"}-\""};
  var peg$c103 = {"type":"class","value":"[*#:;]","description":"[*#:;]"};
  var peg$c104 = {"type":"literal","value":"+","description":"\"+\""};
  var peg$c105 = {"type":"class","value":"[^\\t\\n\\v />\\0]","description":"[^\\t\\n\\v />\\0]"};
  var peg$c106 = {"type":"literal","value":"!","description":"\"!\""};
  var peg$c107 = {"type":"literal","value":"!!","description":"\"!!\""};
  var peg$c108 = {"type":"literal","value":"=>","description":"\"=>\""};
  var peg$c109 = {"type":"literal","value":"||","description":"\"||\""};
  var peg$c110 = {"type":"literal","value":"{{!}}{{!}}","description":"\"{{!}}{{!}}\""};
  var peg$c111 = {"type":"class","value":"[-+A-Z]","description":"[-+A-Z]"};
  var peg$c112 = {"type":"class","value":"[^{}|;]","description":"[^{}|;]"};
  var peg$c113 = {"type":"class","value":"[a-z]","description":"[a-z]"};
  var peg$c114 = {"type":"class","value":"[-a-z]","description":"[-a-z]"};

  // actions
  function peg$a0() {
  
        if (endOffset() === input.length) {
            emitChunk([ new EOFTk() ]);
        }
        // terminate the loop
        return false;
      
  }
  function peg$a1() {
  
        // end is passed inline as a token, as well as a separate event for now.
        emitChunk([ new EOFTk() ]);
        return true;
    
  }
  function peg$a2(sc) {
   return endOffset(); 
  }
  function peg$a3(sc, startPos, b, p) {
   assert(false); return false; 
  }
  function peg$a4(sc, startPos, b, p, ta) {
   return endOffset(); 
  }
  function peg$a5(sc, startPos, b, p, ta, tsEndPos, s2) {
  
          ta = ta.slice(0); // ta is immutable when cached
          var coms = tu.popComments(ta);
          if (coms) {
            tsEndPos = coms.commentStartPos;
          }
  
          var da = { tsr: [startPos, tsEndPos] };
          if (p !== "|") {
              // Variation from default
              da.startTagSrc = b + p;
          }
  
          sc.push(new TagTk('table', ta, da));
          if (coms) {
            sc = sc.concat(coms.buf);
          }
          return sc.concat(s2);
      
  }
  function peg$a6(proto, addr, c, s) {
   return s; 
  }
  function peg$a7(proto, addr, path) {
   return addr.length > 0 || path.length > 0; 
  }
  function peg$a8(proto, addr, path) {
  
      return tu.flattenString([proto, addr].concat(path));
  
  }
  function peg$a9(as, s, p) {
  
          return [as, s, p];
      
  }
  function peg$a10(r) {
   return tu.flattenIfArray(r); 
  }
  function peg$a11(literal, p) {
  
                var flat = tu.flattenString(p);
                // There are templates present
                return ((Array.isArray(flat)) && (flat.length > 0));
              
  }
  function peg$a12(addr, sp) {
   return endOffset(); 
  }
  function peg$a13(addr, sp, targetOff, content) {
  
              return [
                  new SelfclosingTagTk('extlink', [
                      new KV('href', tu.flattenString(addr)),
                      new KV('mw:content', content || ''),
                      new KV('spaces', sp),
                  ], {
                      tsr: tsrOffsets(),
                      extLinkContentOffsets: [targetOff, endOffset() - 1],
                  }),
              ];
          
  }
  function peg$a14(b) {
  
      // Clear the tokenizer's backtracking cache after matching each
      // toplevelblock. There won't be any backtracking as a document is just a
      // sequence of toplevelblocks, so the cache for previous toplevelblocks
      // will never be needed.
      var end = startOffset();
      for (; prevOffset < end; prevOffset++) {
          peg$cache[prevOffset] = undefined;
      }
  
      var tokens;
      if (Array.isArray(b) && b.length) {
          tokens = tu.flattenIfArray(b);
      } else if (b && b.constructor === String) {
          tokens = [b];
      }
  
      // Emit tokens for this toplevelblock. This feeds a chunk to the parser pipeline.
      if (tokens) {
          emitChunk(tokens);
      }
  
      // We don't return any tokens to the start rule to save memory. We
      // just emitted them already to our consumers.
      return true;
    
  }
  function peg$a15() {
   return [new NlTk(tsrOffsets())]; 
  }
  function peg$a16(c) {
  
          return [new CommentTk(c, { tsr: tsrOffsets() })];
      
  }
  function peg$a17(extTag, h, extlink, templatedepth, preproc, equal, table, templateArg, tableCellArg, semicolon, arrow, linkdesc, colon, th) {
  
              return inlineBreaks(input, endOffset(), {
                  extTag: extTag,
                  h: h,
                  extlink: extlink,
                  templatedepth: templatedepth,
                  preproc: preproc,
                  equal: equal,
                  table: table,
                  templateArg: templateArg,
                  tableCellArg: tableCellArg,
                  semicolon: semicolon,
                  arrow: arrow,
                  linkdesc: linkdesc,
                  colon: colon,
                  th: th
              });
          
  }
  function peg$a18(templatedepth) {
  
        // Refuse to recurse beyond `maxDepth` levels. Default in the PHP parser
        // is $wgMaxTemplateDepth = 40; This is to prevent crashing from
        // buggy wikitext with lots of unclosed template calls, as in
        // eswiki/Usuario:C%C3%A1rdenas/PRUEBAS?oldid=651094
        return templatedepth + 1 < env.conf.maxDepth;
      
  }
  function peg$a19(templatedepth, t) {
   return t; 
  }
  function peg$a20(cc) {
  
      // if this is an invalid entity, don't tag it with 'mw:Entity'
      if (cc.length > 2 /* decoded entity would be 1 or 2 UTF-16 characters */) {
          return cc;
      }
      return [
          // If this changes, the nowiki extension's toDOM will need to follow suit
          new TagTk('span', [new KV('typeof', 'mw:Entity')], { src: text(), srcContent: cc, tsr: tsrOffsets('start') }),
          cc,
          new EndTagTk('span', [], { tsr: tsrOffsets('end') }),
      ];
  
  }
  function peg$a21(s) {
   return endOffset(); 
  }
  function peg$a22(s, namePos0, name) {
   return endOffset(); 
  }
  function peg$a23(s, namePos0, name, namePos, v) {
   return v; 
  }
  function peg$a24(s, namePos0, name, namePos, vd) {
  
      // NB: Keep in sync w/ generic_newline_attribute
      var res;
      // Encapsulate protected attributes.
      if (typeof name === 'string') {
          name = tu.protectAttrs(name);
      }
      if (vd !== null) {
          res = new KV(name, vd.value, [namePos0, namePos, vd.srcOffsets[0], vd.srcOffsets[1]]);
          res.vsrc = input.substring(vd.srcOffsets[0], vd.srcOffsets[1]);
      } else {
          res = new KV(name, '', [namePos0, namePos, namePos, namePos]);
      }
      if (Array.isArray(name)) {
          res.ksrc = input.substring(namePos0, namePos);
      }
      return res;
  
  }
  function peg$a25(c) {
   return new KV(c, ''); 
  }
  function peg$a26() {
   return endOffset(); 
  }
  function peg$a27(namePos0, name) {
   return endOffset(); 
  }
  function peg$a28(namePos0, name, namePos, v) {
   return v; 
  }
  function peg$a29(namePos0, name, namePos, vd) {
  
      // NB: Keep in sync w/ table_attibute
      var res;
      // Encapsulate protected attributes.
      if (typeof name === 'string') {
          name = tu.protectAttrs(name);
      }
      if (vd !== null) {
          res = new KV(name, vd.value, [namePos0, namePos, vd.srcOffsets[0], vd.srcOffsets[1]]);
          res.vsrc = input.substring(vd.srcOffsets[0], vd.srcOffsets[1]);
      } else {
          res = new KV(name, '', [namePos0, namePos, namePos, namePos]);
      }
      if (Array.isArray(name)) {
          res.ksrc = input.substring(namePos0, namePos);
      }
      return res;
  
  }
  function peg$a30(c) {
  
      return tu.flattenStringlist(c);
    
  }
  function peg$a31() {
   return endOffset() === input.length; 
  }
  function peg$a32(r, cil, bl) {
   return [r].concat(cil, bl || []); 
  }
  function peg$a33(c) {
   return c; 
  }
  function peg$a34(rs) {
   return rs; 
  }
  function peg$a35(s) {
   return s; 
  }
  function peg$a36(a) {
   return a; 
  }
  function peg$a37(a, b) {
   return [a].concat(b); 
  }
  function peg$a38(encoded) {
   return decodeEntity(encoded) 
  }
  function peg$a39(s) {
  
        if (s.length) {
            return [s];
        } else {
            return [];
        }
    
  }
  function peg$a40(q, r) {
   return r.length > 0 || q.length > 0; 
  }
  function peg$a41(q, r) {
   return tu.flattenString([q].concat(r)); 
  }
  function peg$a42(s, t, q) {
  
        return tu.getAttrVal(t, startOffset() + s.length, endOffset() - q.length);
      
  }
  function peg$a43(s, t) {
  
        return tu.getAttrVal(t, startOffset() + s.length, endOffset());
      
  }
  function peg$a44(r) {
  
          return tu.flattenString(r);
      
  }
  function peg$a45() {
   return endOffset() === 0 && !options.pipelineOffset; 
  }
  function peg$a46(rw, sp, c, wl) {
  
        return wl.length === 1 && wl[0] && wl[0].constructor !== String;
    
  }
  function peg$a47(rw, sp, c, wl) {
  
      var link = wl[0];
      if (sp) { rw += sp; }
      if (c) { rw += c; }
      // Build a redirect token
      return new SelfclosingTagTk(
          'mw:redirect',
          // Put 'href' into attributes so it gets template-expanded
          [KV.lookupKV(link.attribs, 'href')],
          {
            src: rw,
            tsr: tsrOffsets(),
            linkTk: link,
          }
        );
  
  }
  function peg$a48(st, tl) {
   return tl; 
  }
  function peg$a49(st, bt, stl) {
   return bt.concat(stl); 
  }
  function peg$a50(st, bts) {
   return bts; 
  }
  function peg$a51(st, r) {
  
            return st.concat(r);
        
  }
  function peg$a52(s, os, so) {
   return os.concat(so); 
  }
  function peg$a53(s, s2, bl) {
  
          return s.concat(s2 || [], bl);
      
  }
  function peg$a54(tag) {
   return tag; 
  }
  function peg$a55(s1, s2, c) {
  
        return s1.concat(s2, c);
    
  }
  function peg$a56(preproc, t) {
  
          preproc.set(null);
          return t;
      
  }
  function peg$a57(r) {
  
      return tu.flattenString(r);
    
  }
  function peg$a58() {
   return /\w/.test(input[endOffset() - 1] || ''); 
  }
  function peg$a59(bs) {
  
      if (env.conf.wiki.isMagicWord(bs)) {
        return [
          new SelfclosingTagTk('behavior-switch', [ new KV('word', bs) ],
            { tsr: tsrOffsets(), src: bs, magicSrc: bs }
          ),
        ];
      } else {
        return [ bs ];
      }
    
  }
  function peg$a60(quotes) {
  
      // sequences of four or more than five quotes are assumed to start
      // with some number of plain-text apostrophes.
      var plainticks = 0;
      var result = [];
      if (quotes.length === 4) {
          plainticks = 1;
      } else if (quotes.length > 5) {
          plainticks = quotes.length - 5;
      }
      if (plainticks > 0) {
          result.push(quotes.substring(0, plainticks));
      }
      // mw-quote token Will be consumed in token transforms
      var tsr = tsrOffsets();
      tsr[0] += plainticks;
      var mwq = new SelfclosingTagTk('mw-quote', [new KV('value', quotes.substring(plainticks))], { tsr: tsr });
      if (quotes.length > 2) {
          mwq.addAttribute('preceding-2chars', input.substring(tsr[0] - 2, tsr[0]));
      }
      result.push(mwq);
      return result;
  
  }
  function peg$a61(n) {
   return tu.isIncludeTag(n.toLowerCase()); 
  }
  function peg$a62(il, sol_il) {
  
      il = il[0];
      var lname = il.name.toLowerCase();
      if (!tu.isIncludeTag(lname)) { return false; }
      // Preserve SOL where necessary (for onlyinclude and noinclude)
      // Note that this only works because we encounter <*include*> tags in
      // the toplevel content and we rely on the php preprocessor to expand
      // templates, so we shouldn't ever be tokenizing inInclude.
      // Last line should be empty (except for comments)
      if (lname !== "includeonly" && sol_il && il.constructor === TagTk) {
          var dp = il.dataAttribs;
  		var inclContent = dp.src.substring(dp.extTagOffsets[1] - dp.extTagOffsets[0], dp.extTagOffsets[2] - dp.extTagOffsets[0]);
          var last = lastItem(inclContent.split('\n'));
          if (!/^(<!--([^-]|-(?!->))*-->)*$/.test(last)) {
              return false;
          }
      }
      return true;
    
  }
  function peg$a63(il, sol_il) {
   return il; 
  }
  function peg$a64(s, ill) {
   return ill || []; 
  }
  function peg$a65(s, ce) {
   return ce || s.length > 2; 
  }
  function peg$a66(s, ce) {
   return endOffset(); 
  }
  function peg$a67(s, ce, endTPos, spc) {
  
          var c;
          var e;
          var level;
          if (ce) {
              c = ce[0];
              e = ce[1];
              level = Math.min(s.length, e.length);
          } else {
              // split up equal signs into two equal parts, with at least
              // one character in the middle.
              level = Math.floor((s.length - 1) / 2);
              c = ['='.repeat(s.length - 2 * level)];
              s = e = '='.repeat(level);
          }
          level = Math.min(6, level);
          // convert surplus equals into text
          if (s.length > level) {
              // Avoid modifying a cached result
              c = Util.clone(c, false);
              var extras1 = s.substr(0, s.length - level);
              if (c[0].constructor === String) {
                  c[0] = extras1 + c[0];
              } else {
                  c.unshift(extras1);
              }
          }
          if (e.length > level) {
              // Avoid modifying a cached result
              c = Util.clone(c, false);
              var extras2 = e.substr(0, e.length - level);
              var lastElem = lastItem(c);
              if (lastElem.constructor === String) {
                  c[c.length - 1] += extras2;
              } else {
                  c.push(extras2);
              }
          }
  
          var tsr = tsrOffsets('start');
          tsr[1] += level;
          // Match PHP behavior by (a) making headingIndex part of tokenizer
          // state(don't reuse pipeline!) and (b) assigning the index when
          // ==*== is tokenized, even if we're inside a template argument
          // or other context which won't end up putting the heading
          // on the output page.  T213468/T214538
          headingIndex++;
          return [
            new TagTk('h' + level, [], { tsr: tsr, tmp: { headingIndex } }),
          ].concat(c, [
            new EndTagTk('h' + level, [], { tsr: [endTPos - level, endTPos] }),
            spc,
          ]);
        
  }
  function peg$a68(r) {
   return r; 
  }
  function peg$a69(d) {
   return undefined; 
  }
  function peg$a70(d) {
   return true; 
  }
  function peg$a71(d, lineContent) {
  
      var dataAttribs = {
        tsr: tsrOffsets(),
        lineContent: lineContent,
      };
      if (d.length > 0) {
        dataAttribs.extra_dashes = d.length;
      }
      return new SelfclosingTagTk('hr', [], dataAttribs);
    
  }
  function peg$a72(tl) {
  
          return tl;
      
  }
  function peg$a73(end, name, extTag, isBlock) {
  
          if (extTag) {
              return isExtTag(name);
          } else {
              return isXMLTag(name, isBlock);
          }
      
  }
  function peg$a74(end, name, extTag, isBlock, attribs, selfclose) {
  
          var lcName = name.toLowerCase();
  
          // Extension tags don't necessarily have the same semantics as html tags,
          // so don't treat them as void elements.
          var isVoidElt = HTMLTags.Void.includes(lcName.toUpperCase()) && !extTag;
  
          // Support </br>
          if (lcName === 'br' && end) {
              end = null;
          }
  
          var tsr = tsrOffsets();
          tsr[0]--; // For "<" matched at the start of xmlish_tag rule
          var res = tu.buildXMLTag(name, lcName, attribs, end, !!selfclose || isVoidElt, tsr);
  
          // change up data-attribs in one scenario
          // void-elts that aren't self-closed ==> useful for accurate RT-ing
          if (!selfclose && isVoidElt) {
              res.dataAttribs.selfClose = undefined;
              res.dataAttribs.noClose = true;
          }
  
          var met = maybeExtensionTag(res);
          return Array.isArray(met) ? met : [met];
      
  }
  function peg$a75(sp) {
   return endOffset(); 
  }
  function peg$a76(sp, p, c) {
  
          return [
              sp,
              new SelfclosingTagTk("meta", [new KV('typeof', 'mw:EmptyLine')], {
                  tokens: tu.flattenIfArray(c),
                  tsr: [p, endOffset()],
              }),
          ];
      
  }
  function peg$a77() {
  
        // Use the sol flag only at the start of the input
        // Flag should always be an actual boolean (not falsy or undefined)
        assert(typeof options.sol === 'boolean');
        return endOffset() === 0 && options.sol;
    
  }
  function peg$a78() {
   return []; 
  }
  function peg$a79(p, target) {
   return endOffset(); 
  }
  function peg$a80(p, target, p0, v) {
   return endOffset(); 
  }
  function peg$a81(p, target, p0, v, p1) {
   return { tokens: v, srcOffsets: [p0, p1] }; 
  }
  function peg$a82(p, target, params) {
  
        params = params.map(function(o) {
          var s = o.srcOffsets;
          return new KV('', tu.flattenIfArray(o.tokens), [s[0], s[0], s[0], s[1]]);
        });
        if (target === null) { target = { tokens: '', srcOffsets: [p, p, p, p] }; }
        // Insert target as first positional attribute, so that it can be
        // generically expanded. The TemplateHandler then needs to shift it out
        // again.
        params.unshift(new KV(tu.flattenIfArray(target.tokens), '', target.srcOffsets));
        var obj = new SelfclosingTagTk('templatearg', params, { tsr: tsrOffsets(), src: text() });
        return obj;
      
  }
  function peg$a83(leadWS, target) {
   return endOffset(); 
  }
  function peg$a84(leadWS, target, p0, v) {
   return endOffset(); 
  }
  function peg$a85(leadWS, target, p0, v, p) {
   return new KV('', tu.flattenIfArray(v), [p0, p0, p0, p]); 
  }
  function peg$a86(leadWS, target, r) {
   return r; 
  }
  function peg$a87(leadWS, target, params, trailWS) {
  
        // Insert target as first positional attribute, so that it can be
        // generically expanded. The TemplateHandler then needs to shift it out
        // again.
        params.unshift(new KV(tu.flattenIfArray(target.tokens), '', target.srcOffsets));
        var obj = new SelfclosingTagTk('template', params, { tsr: tsrOffsets(), src: text(), tmp: { leadWS, trailWS } });
        return obj;
      
  }
  function peg$a88(target) {
   return endOffset(); 
  }
  function peg$a89(target, tpos, lcs) {
  
        var pipeTrick = (lcs.length === 1 && lcs[0].v === null);
        var textTokens = [];
        if (target === null || pipeTrick) {
          textTokens.push("[[");
          if (target) {
            textTokens.push(target);
          }
          lcs.forEach(function(a) {
            // a is a mw:maybeContent attribute
            textTokens.push("|");
            if (a.v !== null) { textTokens.push(a.v); }
          });
          textTokens.push("]]");
          return textTokens;
        }
        var obj = new SelfclosingTagTk('wikilink');
        var hrefKV = new KV('href', target);
        hrefKV.vsrc = input.substring(startOffset() + 2, tpos);
        // XXX: Point to object with path, revision and input information
        // obj.source = input;
        obj.attribs.push(hrefKV);
        obj.attribs = obj.attribs.concat(lcs);
        obj.dataAttribs = {
            tsr: tsrOffsets(),
            src: text(),
        };
        return [obj];
    
  }
  function peg$a90(preproc) {
   preproc.set(null); return true; 
  }
  function peg$a91(preproc, a) {
  
          return a;
      
  }
  function peg$a92(extToken) {
   return extToken[0].name === 'extension'; 
  }
  function peg$a93(extToken) {
   return extToken[0]; 
  }
  function peg$a94(proto, addr, c, s, rhe) {
   return /^[<>\u00A0]$/.test(rhe); 
  }
  function peg$a95(proto, addr, path) {
  
      // as in Parser.php::makeFreeExternalLink, we're going to
      // yank trailing punctuation out of this match.
      var url = tu.flattenStringlist([proto, addr].concat(path));
      // only need to look at last element; HTML entities are strip-proof.
      var last = lastItem(url);
      var trim = 0;
      if (last && last.constructor === String) {
        var strip = ',;\\\\\.:!\?'; //,;\.:!?
        if (path.indexOf("(") === -1) {
          strip += '\\)';
        }
        strip = new RegExp('[' + strip + ']*$');
        trim = strip.exec(last)[0].length;
        url[url.length - 1] = last.slice(0, last.length - trim);
      }
      url = tu.flattenStringlist(url);
      if (url.length === 1 && url[0].constructor === String && url[0].length <= proto.length) {
        return null; // ensure we haven't stripped everything: T106945
      }
      peg$currPos -= trim;
      return url;
  
  }
  function peg$a96(r) {
   return r !== null; 
  }
  function peg$a97(r) {
  
    return [new SelfclosingTagTk('urllink', [new KV('href', r)], { tsr: tsrOffsets() })];
  
  }
  function peg$a98(ref, sp, identifier) {
  
      var base_urls = {
        'RFC': 'https://tools.ietf.org/html/rfc%s',
        'PMID': '//www.ncbi.nlm.nih.gov/pubmed/%s?dopt=Abstract',
      };
      return [
          new SelfclosingTagTk('extlink', [
             new KV('href', tu.sprintf(base_urls[ref], identifier)),
             new KV('mw:content', tu.flattenString([ref, sp, identifier])),
             new KV('typeof', 'mw:ExtLink/' + ref),
          ],
          { stx: "magiclink", tsr: tsrOffsets() }),
      ];
  
  }
  function peg$a99(sp, isbn) {
  
          // Convert isbn token-and-entity array to stripped string.
          return tu.flattenStringlist(isbn).filter(function(e) {
            return e.constructor === String;
          }).join('').replace(/[^\dX]/ig, '').toUpperCase();
        
  }
  function peg$a100(sp, isbn, isbncode) {
  
         // ISBNs can only be 10 or 13 digits long (with a specific format)
         return isbncode.length === 10 ||
               (isbncode.length === 13 && /^97[89]/.test(isbncode));
      
  }
  function peg$a101(sp, isbn, isbncode) {
  
        return [
          new SelfclosingTagTk('extlink', [
             new KV('href', 'Special:BookSources/' + isbncode),
             new KV('mw:content', tu.flattenString(['ISBN', sp, isbn])),
             new KV('typeof', 'mw:WikiLink/ISBN'),
          ],
          { stx: "magiclink", tsr: tsrOffsets() }),
        ];
  
  }
  function peg$a102(lc) {
   return lc; 
  }
  function peg$a103(bullets, c) {
   return endOffset(); 
  }
  function peg$a104(bullets, c, cpos, d) {
  
          // Leave bullets as an array -- list handler expects this
          // TSR: +1 for the leading ";"
          const numBullets = bullets.length + 1;
          const tsr = tsrOffsets('start');
          tsr[1] += numBullets;
          const li1Bullets = bullets.slice();
          li1Bullets.push(";");
          const li1 = new TagTk('listItem', [new KV('bullets', li1Bullets)], { tsr: tsr });
          // TSR: -1 for the intermediate ":"
          const li2Bullets = bullets.slice();
          li2Bullets.push(":");
          const li2 = new TagTk('listItem', [new KV('bullets', li2Bullets)], { tsr: [cpos - 1, cpos], stx: 'row' });
  
          return [ li1 ].concat(c || [], [ li2 ], d || []);
      
  }
  function peg$a105(bullets, tbl, line) {
  
        // Leave bullets as an array -- list handler expects this
        var tsr = tsrOffsets('start');
        tsr[1] += bullets.length;
        var li = new TagTk('listItem', [new KV('bullets', bullets)], { tsr: tsr });
        return tu.flattenIfArray([li, tbl || [], line || []]);
    
  }
  function peg$a106(bullets, c) {
  
      // Leave bullets as an array -- list handler expects this
      var tsr = tsrOffsets('start');
      tsr[1] += bullets.length;
      var li = new TagTk('listItem', [new KV('bullets', bullets)], { tsr: tsr });
      return [ li ].concat(c || []);
    
  }
  function peg$a107(spc) {
  
          if (spc.length) {
              return [spc];
          } else {
              return [];
          }
      
  }
  function peg$a108(sc, startPos, p, b) {
  
        var tblEnd = new EndTagTk('table', [], { tsr: [startPos, endOffset()] });
        if (p !== "|") {
            // p+"<brace-char>" is triggering some bug in pegJS
            // I cannot even use that expression in the comment!
            tblEnd.dataAttribs.endTagSrc = p + b;
        }
        return sc.concat([tblEnd]);
    
  }
  function peg$a109(tpt) {
  
          return { tokens: tpt, srcOffsets: tsrOffsets() };
      
  }
  function peg$a110(name) {
   return endOffset(); 
  }
  function peg$a111(name, kEndPos) {
   return endOffset(); 
  }
  function peg$a112(name, kEndPos, vStartPos, tpv) {
  
              return { kEndPos: kEndPos, vStartPos: vStartPos, value: (tpv && tpv.tokens) || [] };
          
  }
  function peg$a113(name, val) {
  
        if (val !== null) {
            if (val.value !== null) {
              return new KV(name, tu.flattenIfArray(val.value), [startOffset(), val.kEndPos, val.vStartPos, endOffset()]);
            } else {
              return new KV(tu.flattenIfArray(name), '', [startOffset(), val.kEndPos, val.vStartPos, endOffset()]);
            }
        } else {
          return new KV('', tu.flattenIfArray(name), [startOffset(), startOffset(), startOffset(), endOffset()]);
        }
      
  }
  function peg$a114() {
  
      return new KV('', '', [startOffset(), startOffset(), startOffset(), endOffset()]);
    
  }
  function peg$a115(r) {
  
        return tu.flattenStringlist(r);
    
  }
  function peg$a116(startPos, lt) {
  
          var maybeContent = new KV('mw:maybeContent', lt, [startPos, endOffset()]);
          maybeContent.vsrc = input.substring(startPos, endOffset());
          return maybeContent;
    
  }
  function peg$a117(he) {
   return Array.isArray(he) && /^\u00A0$/.test(he[1]); 
  }
  function peg$a118() {
   return startOffset(); 
  }
  function peg$a119(lv0) {
   return env.langConverterEnabled(); 
  }
  function peg$a120(lv0, ff) {
  
           // Avoid mutating cached expression results
           ff = Util.clone(ff, true);
           // if flags contains 'R', then don't treat ; or : specially inside.
           if (ff.flags) {
             ff.raw = ff.flags.has('R') || ff.flags.has('N');
           } else if (ff.variants) {
             ff.raw = true;
           }
           return ff;
         
  }
  function peg$a121(lv0) {
   return !env.langConverterEnabled(); 
  }
  function peg$a122(lv0) {
  
           // if language converter not enabled, don't try to parse inside.
           return { raw: true };
         
  }
  function peg$a123(lv0, f) {
   return f.raw; 
  }
  function peg$a124(lv0, f, lv) {
   return [{ text: lv }]; 
  }
  function peg$a125(lv0, f) {
   return !f.raw; 
  }
  function peg$a126(lv0, f, lv) {
   return lv; 
  }
  function peg$a127(lv0, f, ts) {
   return endOffset(); 
  }
  function peg$a128(lv0, f, ts, lv1) {
  
  
        if (!env.langConverterEnabled()) {
          return [ "-{", ts[0].text.tokens, "}-" ];
        }
        var lvsrc = input.substring(lv0, lv1);
        var attribs = [];
  
        // Do a deep clone since we may be destructively modifying
        // (the `t[fld] = name;` below) the result of a cached expression
        ts = Util.clone(ts, true);
  
        ts.forEach(function(t) {
          // move token strings into KV attributes so that they are
          // properly expanded by early stages of the token pipeline
          ['text','from','to'].forEach(function(fld) {
            if (t[fld] === undefined) { return; }
            var name = 'mw:lv' + attribs.length;
            // Note that AttributeExpander will expect the tokens array to be
            // flattened.  We do that in lang_variant_text / lang_variant_nowiki
            attribs.push(new KV(name, t[fld].tokens, t[fld].srcOffsets));
            t[fld] = name;
          });
        });
        return [
          new SelfclosingTagTk(
            'language-variant',
             attribs,
             {
               tsr: [lv0, lv1],
               src: lvsrc,
               flags: f.flags && Array.from(f.flags).sort(),
               variants: f.variants && Array.from(f.variants).sort(),
               original: f.original,
               flagSp: f.sp,
               texts: ts,
             }),
        ];
      
  }
  function peg$a129(r, preproc) {
  
          preproc.set(null);
          return r;
      
  }
  function peg$a130(ill) {
   return ill; 
  }
  function peg$a131(p, dashes) {
   assert(false); return false; 
  }
  function peg$a132(p, dashes, a) {
   return endOffset(); 
  }
  function peg$a133(p, dashes, a, tagEndPos) {
  
          a = a.slice(0); // a is immutable when cached
          var coms = tu.popComments(a);
          if (coms) {
            tagEndPos = coms.commentStartPos;
          }
  
          var da = {
            tsr: [ startOffset(), tagEndPos ],
            startTagSrc: p + dashes,
          };
  
          // We rely on our tree builder to close the row as needed. This is
          // needed to support building tables from fragment templates with
          // individual cells or rows.
          var trToken = new TagTk('tr', a, da);
  
          var res = [ trToken ];
          if (coms) {
            res = res.concat(coms.buf);
          }
          return res;
      
  }
  function peg$a134(p, td) {
   return endOffset(); 
  }
  function peg$a135(p, td, tagEndPos, tds) {
  
          // Avoid modifying a cached result
          td = td.slice();
          td[0] = Util.clone(td[0]);
  
          var da = td[0].dataAttribs;
          da.tsr[0] -= p.length; // include "|"
          if (p !== "|") {
              // Variation from default
              da.startTagSrc = p;
          }
          return td.concat(tds);
      
  }
  function peg$a136(p, args) {
   return endOffset(); 
  }
  function peg$a137(p, args, tagEndPos, c) {
  
          return tu.buildTableTokens("caption", "|+", args, [startOffset(), tagEndPos], endOffset(), c, true);
      
  }
  function peg$a138(il) {
  
          // il is guaranteed to be an array -- so, tu.flattenIfArray will
          // always return an array
          var r = tu.flattenIfArray(il);
          if (r.length === 1 && r[0].constructor === String) {
              r = r[0];
          }
          return r;
      
  }
  function peg$a139() {
   return ''; 
  }
  function peg$a140(tpt) {
  
          return tpt;
      
  }
  function peg$a141(ff) {
   return ff; 
  }
  function peg$a142(f) {
  
      // Collect & separate flags and variants into a set and ordered list
      var flags = new Set();
      var variants = new Set();
      var flagList = [];
      var flagSpace = [];
      var variantList = [];
      var variantSpace = [];
      var useVariants = false;
      if (f !== null) {
        // lang_variant_flags returns arrays in reverse order.
        f.flags.reverse();
        f.sp.reverse();
        var spPtr = 0;
        f.flags.forEach(function(item) {
          if (item.flag) {
            flagSpace.push(f.sp[spPtr++]);
            flags.add(item.flag);
            flagList.push(item.flag);
            flagSpace.push(f.sp[spPtr++]);
          }
          if (item.variant) {
            variantSpace.push(f.sp[spPtr++]);
            variants.add(item.variant);
            variantList.push(item.variant);
            variantSpace.push(f.sp[spPtr++]);
          }
        });
        if (spPtr < f.sp.length) {
          // handle space after a trailing semicolon
          flagSpace.push(f.sp[spPtr]);
          variantSpace.push(f.sp[spPtr]);
        }
      }
      // Parse flags (this logic is from core/languages/ConverterRule.php
      // in the parseFlags() function)
      if (flags.size === 0 && variants.size === 0) {
        flags.add('$S');
      } else if (flags.has('R')) {
        flags = new Set(['R']); // remove other flags
      } else if (flags.has('N')) {
        flags = new Set(['N']); // remove other flags
      } else if (flags.has('-')) {
        flags = new Set(['-']); // remove other flags
      } else if (flags.has('T') && flags.size === 1) {
        flags.add('H');
      } else if (flags.has('H')) {
        // Replace A flag, and remove other flags except T and D
        var nf = new Set(['$+', 'H']);
        if (flags.has('T')) { nf.add('T'); }
        if (flags.has('D')) { nf.add('D'); }
        flags = nf;
      } else if (variants.size > 0) {
        useVariants = true;
      } else {
        if (flags.has('A')) {
          flags.add('$+');
          flags.add('$S');
        }
        if (flags.has('D')) {
          flags.delete('$S');
        }
      }
      if (useVariants) {
        return { variants: variants, original: variantList, sp: variantSpace };
      } else {
        return { flags: flags, original: flagList, sp: flagSpace };
      }
    
  }
  function peg$a143(tokens) {
   return { tokens: tu.flattenStringlist(tokens), srcOffsets: [startOffset(), endOffset()] }; 
  }
  function peg$a144(o, oo) {
   return oo; 
  }
  function peg$a145(o, rest, tr) {
  
        var r = [ o ].concat(rest);
        if (tr) { r.push({ semi: true, sp: tr[1] }); }
        return r;
      
  }
  function peg$a146(lvtext) {
   return [{ text: lvtext }]; 
  }
  function peg$a147(thTag, pp, tht) {
  
              // Avoid modifying a cached result
              tht = tht.slice();
              tht[0] = Util.clone(tht[0]);
  
              var da = tht[0].dataAttribs;
              da.stx = 'row';
              da.tsr[0] -= pp.length; // include "!!" or "||"
  
              if (pp !== "!!" || (da.startTagSrc && da.startTagSrc !== pp)) {
                  // Variation from default
                  da.startTagSrc = pp + (da.startTagSrc ? da.startTagSrc.substring(1) : '');
              }
              return tht;
            
  }
  function peg$a148(thTag, thTags) {
  
          thTag = thTag.slice();
          thTag[0] = Util.clone(thTag[0]);
          thTag[0].dataAttribs.tsr[0]--; // include "!"
          return thTag.concat(thTags);
      
  }
  function peg$a149(arg) {
   return endOffset(); 
  }
  function peg$a150(arg, tagEndPos, td) {
  
          return tu.buildTableTokens("td", "|", arg, [startOffset(), tagEndPos], endOffset(), td);
      
  }
  function peg$a151(p) {
   return p; 
  }
  function peg$a152(pp, tdt) {
  
          // Avoid modifying a cached result
          tdt = tdt.slice();
          tdt[0] = Util.clone(tdt[0]);
  
          var da = tdt[0].dataAttribs;
          da.stx = "row";
          da.tsr[0] -= pp.length; // include "||"
          if (pp !== "||" || (da.startTagSrc && da.startTagSrc !== pp)) {
            // Variation from default
            da.startTagSrc = pp + (da.startTagSrc ? da.startTagSrc.substring(1) : '');
          }
          return tdt;
        
  }
  function peg$a153(b) {
  
          return b;
      
  }
  function peg$a154(b) {
   return b; 
  }
  function peg$a155(c) {
  
        return tu.flattenStringlist(c);
      
  }
  function peg$a156(sp1, f, sp2, more) {
  
      var r = more && more[1] ? more[1] : { sp: [], flags: [] };
      // Note that sp and flags are in reverse order, since we're using
      // right recursion and want to push instead of unshift.
      r.sp.push(sp2);
      r.sp.push(sp1);
      r.flags.push(f);
      return r;
    
  }
  function peg$a157(sp) {
  
      return { sp: [ sp ], flags: [] };
    
  }
  function peg$a158(sp1, lang, sp2, sp3, lvtext) {
  
        return {
          twoway: true,
          lang: lang,
          text: lvtext,
          sp: [sp1, sp2, sp3]
        };
      
  }
  function peg$a159(sp1, from, sp2, lang, sp3, sp4, to) {
  
        return {
          oneway: true,
          from: from,
          lang: lang,
          to: to,
          sp: [sp1, sp2, sp3, sp4]
        };
      
  }
  function peg$a160(arg, tagEndPos, th, d) {
  
              if (th.get() !== false && /\n/.test(text())) {
                  // There's been a newline. Remove the break and continue
                  // tokenizing nested_block_in_tables.
                  th.set(false);
              }
              return d;
          
  }
  function peg$a161(arg, tagEndPos, c) {
  
          return tu.buildTableTokens("th", "!", arg, [startOffset(), tagEndPos], endOffset(), c);
      
  }
  function peg$a162(r) {
  
          return r;
      
  }
  function peg$a163(f) {
   return { flag: f }; 
  }
  function peg$a164(v) {
   return { variant: v }; 
  }
  function peg$a165(b) {
   return { bogus: b }; /* bad flag */
  }
  function peg$a166(n, sp) {
  
          return { tokens: [ n ], srcOffsets: [startOffset(), endOffset() - sp.length] };
      
  }
  function peg$a167(tbl) {
  
          return tbl;
      
  }
  function peg$a168(extToken) {
   return extToken.getAttribute('name') === 'nowiki'; 
  }
  function peg$a169(extToken) {
   return extToken; 
  }
  function peg$a170(extToken) {
  
      var txt = Util.extractExtBody(extToken);
      return decodeEntities(txt);
    
  }

  // initializer
  
  
      var pegIncludes = options.pegIncludes;
      var pegTokenizer = options.pegTokenizer;
  
      var tokenizer = pegTokenizer.tokenizer;
      var env = pegTokenizer.env;
      var pipelineOpts = pegTokenizer.options;
  
      var TokenUtils = pegIncludes.TokenUtils;
      var Util = pegIncludes.Util;
      var PegTokenizer = pegIncludes.PegTokenizer;
      const { KV, TagTk, EndTagTk, SelfclosingTagTk, NlTk, EOFTk, CommentTk } = pegIncludes.Token;
      var HTMLTags = pegIncludes.HTMLTags;
      var tu = pegIncludes.tu;
      var NAMED_ENTITIES = {
        "&apos;":"'",
        "&nbsp;":" ",
        "&iexcl;":"¡",
        "&cent;":"¢",
        "&pound;":"£",
        "&curren;":"¤",
        "&yen;":"¥",
        "&brvbar;":"¦",
        "&sect;":"§",
        "&uml;":"¨",
        "&copy;":"©",
        "&ordf;":"ª",
        "&laquo;":"«",
        "&not;":"¬",
        "&shy;":"\xad",
        "&reg;":"®",
        "&macr;":"¯",
        "&deg;":"°",
        "&plusmn;":"±",
        "&sup2;":"²",
        "&sup3;":"³",
        "&acute;":"´",
        "&micro;":"µ",
        "&para;":"¶",
        "&middot;":"·",
        "&cedil;":"¸",
        "&sup1;":"¹",
        "&ordm;":"º",
        "&raquo;":"»",
        "&frac14;":"¼",
        "&frac12;":"½",
        "&frac34;":"¾",
        "&iquest;":"¿",
        "&Agrave;":"À",
        "&Aacute;":"Á",
        "&Acirc;":"Â",
        "&Atilde;":"Ã",
        "&Auml;":"Ä",
        "&Aring;":"Å",
        "&Aelig;":"Æ",
        "&Ccedil;":"Ç",
        "&Egrave;":"È",
        "&Eacute;":"É",
        "&Ecirc;":"Ê",
        "&Euml;":"Ë",
        "&Igrave;":"Ì",
        "&Iacute;":"Í",
        "&Icirc;":"Î",
        "&Iuml;":"Ï",
        "&ETH;":"Ð",
        "&Ntilde;":"Ñ",
        "&Ograve;":"Ò",
        "&Oacute;":"Ó",
        "&Ocirc;":"Ô",
        "&Otilde;":"Õ",
        "&Ouml;":"Ö",
        "&times;":"×",
        "&Oslash;":"Ø",
        "&Ugrave;":"Ù",
        "&Uacute;":"Ú",
        "&Ucirc;":"Û",
        "&Uuml;":"Ü",
        "&Yacute;":"Ý",
        "&THORN;":"Þ",
        "&szlig;":"ß",
        "&agrave;":"à",
        "&aacute;":"á",
        "&acirc;":"â",
        "&atilde;":"ã",
        "&auml;":"ä",
        "&aring;":"å",
        "&aelig;":"æ",
        "&ccedil;":"ç",
        "&egrave;":"è",
        "&eacute;":"é",
        "&ecirc;":"ê",
        "&euml;":"ë",
        "&igrave;":"ì",
        "&iacute;":"í",
        "&icirc;":"î",
        "&iuml;":"ï",
        "&eth;":"ð",
        "&ntilde;":"ñ",
        "&ograve;":"ò",
        "&oacute;":"ó",
        "&ocirc;":"ô",
        "&otilde;":"õ",
        "&ouml;":"ö",
        "&divide;":"÷",
        "&oslash;":"ø",
        "&ugrave;":"ù",
        "&uacute;":"ú",
        "&ucirc;":"û",
        "&uuml;":"ü",
        "&yacute;":"ý",
        "&thorn;":"þ",
        "&yuml;":"ÿ",
        "&quot;":"\"",
        "&amp;":"&",
        "&lt;":"<",
        "&gt;":">",
        "&OElig;":"Œ",
        "&oelig;":"œ",
        "&Scaron;":"Š",
        "&scaron;":"š",
        "&Yuml;":"Ÿ",
        "&circ;":"ˆ",
        "&tilde;":"˜",
        "&ensp;":"\u2002",
        "&emsp;":"\u2003",
        "&thinsp;":"\u2009",
        "&zwnj;":"\u200C",
        "&zwj;":"\u200D",
        "&lrm;":"\u200E",
        "&rlm;":"\u200F",
        "&ndash;":"–",
        "&mdash;":"—",
        "&lsquo;":"‘",
        "&rsquo;":"’",
        "&sbquo;":"‚",
        "&ldquo;":"“",
        "&rdquo;":"”",
        "&bdquo;":"„",
        "&dagger;":"†",
        "&Dagger;":"‡",
        "&permil;":"‰",
        "&lsaquo;":"‹",
        "&rsaquo;":"›",
        "&euro;":"€",
        "&fnof;":"ƒ",
        "&Alpha;":"Α",
        "&Beta;":"Β",
        "&Gamma;":"Γ",
        "&Delta;":"Δ",
        "&Epsilon;":"Ε",
        "&Zeta;":"Ζ",
        "&Eta;":"Η",
        "&Theta;":"Θ",
        "&Iota;":"Ι",
        "&Kappa;":"Κ",
        "&Lambda;":"Λ",
        "&Mu;":"Μ",
        "&Nu;":"Ν",
        "&Xi;":"Ξ",
        "&Omicron;":"Ο",
        "&Pi;":"Π",
        "&Rho;":"Ρ",
        "&Sigma;":"Σ",
        "&Tau;":"Τ",
        "&Upsilon;":"Υ",
        "&Phi;":"Φ",
        "&Chi;":"Χ",
        "&Psi;":"Ψ",
        "&Omega;":"Ω",
        "&alpha;":"α",
        "&beta;":"β",
        "&gamma;":"γ",
        "&delta;":"δ",
        "&epsilon;":"ε",
        "&zeta;":"ζ",
        "&eta;":"η",
        "&theta;":"θ",
        "&iota;":"ι",
        "&kappa;":"κ",
        "&lambda;":"λ",
        "&mu;":"μ",
        "&nu;":"ν",
        "&xi;":"ξ",
        "&omicron;":"ο",
        "&pi;":"π",
        "&rho;":"ρ",
        "&sigmaf;":"ς",
        "&sigma;":"σ",
        "&tau;":"τ",
        "&upsilon;":"υ",
        "&phi;":"φ",
        "&chi;":"χ",
        "&psi;":"ψ",
        "&omega;":"ω",
        "&thetasym;":"ϑ",
        "&upsih;":"ϒ",
        "&piv;":"ϖ",
        "&bull;":"•",
        "&hellip;":"…",
        "&prime;":"′",
        "&Prime;":"″",
        "&oline;":"‾",
        "&frasl;":"⁄",
        "&weierp;":"℘",
        "&image;":"ℑ",
        "&real;":"ℜ",
        "&trade;":"™",
        "&alefsym;":"ℵ",
        "&larr;":"←",
        "&uarr;":"↑",
        "&rarr;":"→",
        "&darr;":"↓",
        "&harr;":"↔",
        "&crarr;":"↵",
        "&lArr;":"⇐",
        "&uArr;":"⇑",
        "&rArr;":"⇒",
        "&dArr;":"⇓",
        "&hArr;":"⇔",
        "&forall;":"∀",
        "&part;":"∂",
        "&exist;":"∃",
        "&empty;":"∅",
        "&nabla;":"∇",
        "&isin;":"∈",
        "&notin;":"∉",
        "&ni;":"∋",
        "&prod;":"∏",
        "&sum;":"∑",
        "&minus;":"−",
        "&lowast;":"∗",
        "&radic;":"√",
        "&prop;":"∝",
        "&infin;":"∞",
        "&ang;":"∠",
        "&and;":"∧",
        "&or;":"∨",
        "&cap;":"∩",
        "&cup;":"∪",
        "&int;":"∫",
        "&there4;":"∴",
        "&sim;":"∼",
        "&cong;":"≅",
        "&asymp;":"≈",
        "&ne;":"≠",
        "&equiv;":"≡",
        "&le;":"≤",
        "&ge;":"≥",
        "&sub;":"⊂",
        "&sup;":"⊃",
        "&nsub;":"⊄",
        "&sube;":"⊆",
        "&supe;":"⊇",
        "&oplus;":"⊕",
        "&otimes;":"⊗",
        "&perp;":"⊥",
        "&sdot;":"⋅",
        "&lceil;":"⌈",
        "&rceil;":"⌉",
        "&lfloor;":"⌊",
        "&rfloor;":"⌋",
        "&lang;":"\u2329",
        "&rang;":"\u232a",
        "&loz;":"◊",
        "&spades;":"♠",
        "&clubs;":"♣",
        "&hearts;":"♥",
        "&diams;":"♦"
      };
  
      function decodeEntity(encoded) {
        let cp;
        let decoded;
        let hex = /^&#(?:x([A-Fa-f0-9]+)|(\d+));$/.exec(encoded);
        if (hex) {
          if (hex[1]) { // &#xAE
            cp = Number.parseInt(hex[1], 16);
          } else { // &#174
            cp = Number.parseInt(hex[2], 10);
          }
          if (cp > 0x10FFFF) {
            return encoded; // Invalid entity
          }
          if (
            (cp < 0x09) ||
            (cp > 0x0A && cp < 0x20) ||
            (cp > 0x7E && cp < 0xA0) ||
            (cp > 0xD7FF && cp < 0xE000) ||
            (cp > 0xFFFD && cp < 0x10000) ||
            (cp > 0x10FFFF)
          ) {
            return encoded; // Invalid entity
          }
          return String.fromCodePoint(cp);
        } else {
          if (NAMED_ENTITIES.hasOwnProperty(encoded)) {
            return NAMED_ENTITIES[encoded]
          } else {
            return encoded;
          }
        }
      }
      function decodeEntities(text) {
        return text.replace(/&[#0-9a-zA-Z]+;/g, decodeEntity);
      }
  
      var lastItem = function(items) {
        return items[items.length - 1];
      };
  
      var inlineBreaks = tu.inlineBreaks;
  
      var prevOffset = 0;
      var headingIndex = 0;
  
      // Assertions are not safe in the tokenizer, since we catch exceptions
      // thrown and treat it as a "failed match" and backtrack.  Nobody ever
      // sees the assertion failure.  Work around this by using a special
      // assertion method for tokenizer code.
      var assert = function(condition, text) {
        if (condition) { return; }
        env.log('fatal', text || "Tokenizer assertion failure");
      };
  
      // Some shorthands for legibility
      var startOffset = function() {
        return peg$savedPos;
      };
      var endOffset = function() {
        return peg$currPos;
      };
      var tsrOffsets = function(flag) {
        return tu.tsrOffsets(peg$savedPos, peg$currPos, flag);
      };
  
      /*
       * Emit a chunk of tokens to our consumers.  Once this has been done, the
       * current expression can return an empty list (true).
       */
      var emitChunk = function(tokens) {
          if (env.immutable) {
              tokens = Util.clone(tokens, true);
          }
  
          // Shift tsr of all tokens by the pipeline offset
          TokenUtils.shiftTokenTSR(tokens, options.pipelineOffset);
          env.log("trace/peg", pegTokenizer.pipelineId, "---->  ", tokens);
  
          var i;
          var n = tokens.length;
  
          // limit the size of individual chunks
          var chunkLimit = 100000;
          if (n > chunkLimit) {
              i = 0;
              while (i < n) {
                  options.cb(tokens.slice(i, i + chunkLimit));
                  i += chunkLimit;
              }
          } else {
              options.cb(tokens);
          }
      };
  
      /* ------------------------------------------------------------------------
       * Extension tags should be parsed with higher priority than anything else.
       *
       * The trick we use is to strip out the content inside a matching tag-pair
       * and not tokenize it. The content, if it needs to parsed (for example,
       * for <ref>, <*include*> tags), is parsed in a fresh tokenizer context
       * which means any error correction that needs to happen is restricted to
       * the scope of the extension content and doesn't spill over to the higher
       * level.  Ex: <math><!--foo</math>.
       *
       * IGNORE: {{ this just balances the blocks in this comment for pegjs
       *
       * This trick also lets us prevent extension content (that don't accept WT)
       * from being parsed as wikitext (Ex: <math>\frac{foo\frac{bar}}</math>)
       * We don't want the "}}" being treated as a template closing tag and
       * closing outer templates.
       * --------------------------------------------------------------------- */
  
      var isXMLTag = function(name, block) {
          var uName = name.toUpperCase();
          return block
              ? (name !== 'VIDEO' && HTMLTags.HTML4Block.includes(name))
              : HTMLTags.HTML5.includes(uName) || HTMLTags.DepHTML.includes(uName);
      };
  
      var isExtTag = function(name) {
          var lName = name.toLowerCase();
          var isInstalledExt = env.conf.wiki.extTags.includes(lName);
          var isIncludeTag = tu.isIncludeTag(lName);
          return isInstalledExt || isIncludeTag;
      };
  
      var maybeExtensionTag = function(t) {
          var tagName = t.name.toLowerCase();
          var isInstalledExt = env.conf.wiki.extTags.includes(tagName);
          var isIncludeTag = tu.isIncludeTag(tagName);
  
          // Extensions have higher precedence when they shadow html tags.
          if (!(isInstalledExt || isIncludeTag)) {
              return t;
          }
  
          var dp = t.dataAttribs;
          var skipPos = peg$currPos;
  
          switch (t.constructor) {
          case EndTagTk:
              if (isIncludeTag) {
                  return t;
              }
              // Similar to TagTk, we rely on the sanitizer to convert to text
              // where necessary and emit tokens to ease the wikitext escaping
              // code.  However, extension tags that shadow html tags will see
              // their unmatched end tags dropped while tree building, since
              // the sanitizer will let them through.
              return t;  // not text()
          case SelfclosingTagTk:
              dp.src = input.substring(dp.tsr[0], dp.tsr[1]);
              dp.extTagOffsets = [dp.tsr[0], dp.tsr[1], dp.tsr[1], dp.tsr[1]];
              if (isIncludeTag) {
                  return t;
              }
              break;
          case TagTk:
              var endTagRE = new RegExp("^[\\s\\S]*?(</" + tagName + "\\s*>)", "i");
              var restOfInput = input.substring(dp.tsr[0]);
              var tagContent = restOfInput.match(endTagRE);
  
              if (!tagContent) {
                  dp.src = input.substring(dp.tsr[0], dp.tsr[1]);
                  dp.extTagOffsets = [dp.tsr[0], dp.tsr[1], dp.tsr[1], dp.tsr[1]];
                  if (isIncludeTag) {
                      return t;
                  } else {
                      // This is undefined behaviour.  The php parser currently
                      // returns text here (see core commit 674e8388cba),
                      // whereas this results in unclosed
                      // extension tags that shadow html tags falling back to
                      // their html equivalent.  The sanitizer will take care
                      // of converting to text where necessary.  We do this to
                      // simplify `hasWikitextTokens` when escaping wikitext,
                      // which wants these as tokens because it's otherwise
                      // lacking in context.
                      return t;  // not text()
                  }
              }
  
              var extSrc = tagContent[0];
  			var extEndOffset = dp.tsr[0] + extSrc.length;
              var extEndTagWidth = tagContent[1].length;
  
              if (pipelineOpts.inTemplate) {
                  // Support 1-level of nesting in extensions tags while
                  // tokenizing in templates to support the #tag parser function.
                  //
                  // It's necessary to permit this broadly in templates because
                  // there's no way to distinguish whether the nesting happened
                  // while expanding the #tag parser function, or just a general
                  // syntax errors.  In other words,
                  //
                  //   hi<ref>ho<ref>hi</ref>ho</ref>
                  //
                  // and
                  //
                  //   hi{{#tag:ref|ho<ref>hi</ref>ho}}
                  //
                  // found in template are returned indistinguishably after a
                  // preprocessing request, though the php parser renders them
                  // differently.  #tag in template is probably a common enough
                  // use case that we want to accept these false positives,
                  // though another approach could be to drop this code here, and
                  // invoke a native #tag handler and forgo those in templates.
                  //
                  // Expand `extSrc` as long as there is a <tagName> found in the
                  // extension source body.
                  var s = extSrc.substring(endOffset() - dp.tsr[0]);
                  while (s && s.match(new RegExp("<" + tagName + "[^/<>]*>", "i"))) {
                      tagContent = restOfInput.substring(extSrc.length).match(endTagRE);
                      if (tagContent) {
                          s = tagContent[0];
  						extEndOffset += s.length;
                          extEndTagWidth = tagContent[1].length;
                          extSrc += s;
                      } else {
                          s = null;
                      }
                  }
              }
  
              // Extension content source
              dp.src = extSrc;
              dp.extTagOffsets = [dp.tsr[0], dp.tsr[1], extEndOffset - extEndTagWidth, extEndOffset];
  
              skipPos = dp.extTagOffsets[2];
  
              // If the xml-tag is a known installed (not native) extension,
              // skip the end-tag as well.
              if (isInstalledExt) {
                  skipPos = dp.extTagOffsets[3];
              }
              break;
          default:
              assert(false, 'Should not be reachable.');
          }
  
          peg$currPos = skipPos;
  
          if (isInstalledExt) {
              // update tsr[1] to span the start and end tags.
              dp.tsr[1] = endOffset();  // was just modified above
              return new SelfclosingTagTk('extension', [
                  new KV('typeof', 'mw:Extension'),
                  new KV('name', tagName),
                  new KV('source', dp.src),
                  new KV('options', t.attribs),
              ], dp);
          } else if (isIncludeTag) {
              // Parse ext-content, strip eof, and shift tsr
  			      var extContent = dp.src.substring(dp.extTagOffsets[1] - dp.extTagOffsets[0], dp.extTagOffsets[2] - dp.extTagOffsets[0]);
              var separateTokenizer = new PegTokenizer(tokenizer, env);
              separateTokenizer.setSourceOffsets(dp.extTagOffsets[1], dp.extTagOffsets[2]);
              var extContentToks = separateTokenizer.tokenizeSync(extContent);
              if (dp.extTagOffsets[2] !== dp.extTagOffsets[3]) {
                  extContentToks = TokenUtils.stripEOFTkfromTokens(extContentToks);
              }
              return [t].concat(extContentToks);
          } else {
              assert(false, 'Should not be reachable.');
          }
      };
  

  // generated
  function* peg$streamstart_async(silence, param_preproc) {
    var r1,p2,r3,r4;
    for (;;) {
      choice_1: {
      r1 = peg$parsetlb(silence, param_preproc);
      if (r1!==peg$FAILED) {
        break choice_1;
      }
      seq_1: {
      p2 = peg$currPos;
      r3 = [];
      for (;;) {
        r4 = peg$parsenewlineToken(silence);
        if (r4!==peg$FAILED) {
          r3.push(r4);
        } else {
          break;
        }
      }
      // free r4
      peg$savedPos = peg$currPos;
      r4 = peg$a0();
      if (r4) {
        r4 = void 0;
      } else {
        r4 = peg$FAILED;
        peg$currPos = p2;
        r1 = peg$FAILED;
        break seq_1;
      }
      r1 = [r3,r4];
      } // seq_1
      // free p2
      } // choice_1
      if (r1!==peg$FAILED) {
        yield r1;
      } else {
        if (peg$currPos < input.length) {
          peg$fail(peg$c0);
          throw peg$buildParseException();
        }
        break;
      }
    }
  }
  function peg$parsestart(silence, param_preproc) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [0,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    for (;;) {
      r5 = peg$discardtlb(true, param_preproc);
      if (r5===peg$FAILED) {
        break;
      }
    }
    // free r5
    r4 = true;
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r4
    for (;;) {
      r5 = peg$discardnewlineToken(true);
      if (r5===peg$FAILED) {
        break;
      }
    }
    // free r5
    r4 = true;
    if (r4===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r4
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a1();
    } else {
      if (!silence) {peg$fail(peg$c1);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsetable_start_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,r10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [174,boolParams & 0x3bef,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      choice_1: {
      r5 = peg$parsespace(true);
      if (r5!==peg$FAILED) {
        break choice_1;
      }
      r5 = peg$parsecomment(true);
      } // choice_1
      if (r5!==peg$FAILED) {
        r4.push(r5);
      } else {
        break;
      }
    }
    // sc <- r4
    // free r5
    p6 = peg$currPos;
    r5 = '';
    // startPos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a2(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // b <- r7
    if (input.charCodeAt(peg$currPos) === 123) {
      r7 = "{";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsepipe(true);
    // p <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    r9 = peg$parsetable_attributes(true, boolParams & ~0x10, param_templatedepth, param_preproc, param_th);
    if (r9!==peg$FAILED) {
      break choice_2;
    }
    peg$savedPos = peg$currPos;
    r9 = peg$a3(r4, r5, r7, r8);
    if (r9) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
    }
    } // choice_2
    // ta <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p11 = peg$currPos;
    r10 = '';
    // tsEndPos <- r10
    if (r10!==peg$FAILED) {
      peg$savedPos = p11;
      r10 = peg$a4(r4, r5, r7, r8, r9);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r12 = [];
    for (;;) {
      r13 = peg$parsespace(true);
      if (r13!==peg$FAILED) {
        r12.push(r13);
      } else {
        break;
      }
    }
    // s2 <- r12
    // free r13
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a5(r4, r5, r7, r8, r9, r10, r12);
    } else {
      if (!silence) {peg$fail(peg$c2);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseurl(silence, param_preproc) {
    var r1,p2,p3,r4,r5,r6,r7,p8,p9,r10,r11,r12,p13,r14,r15,p16,r17,r18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [52,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseurl_protocol(true);
    // proto <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parseIPAddress(true);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = '';
    } // choice_1
    // addr <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    for (;;) {
      choice_2: {
      seq_2: {
      p8 = peg$currPos;
      p9 = peg$currPos;
      r10 = peg$discardinline_breaks(true, 0x0, 0, param_preproc, new peg$Reference(null));
      if (r10 === peg$FAILED) {
        r10 = void 0;
      } else {
        r10 = peg$FAILED;
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p9
      r11 = input.charAt(peg$currPos);
      // c <- r11
      if (/^[^&[\]{"<>\0- \uFFFD \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r11)) {
        peg$currPos++;
      } else {
        r11 = peg$FAILED;
        peg$currPos = p8;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = [r10,r11];
      } // seq_2
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      // free p8
      r7 = peg$parsecomment(true);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      r7 = peg$parsetplarg_or_template(true, 0x0, 0, new peg$Reference(null), param_preproc);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      p8 = peg$currPos;
      r12 = input.charAt(peg$currPos);
      // s <- r12
      if (/^[:{]/.test(r12)) {
        peg$currPos++;
      } else {
        r12 = peg$FAILED;
      }
      r7 = r12;
      if (r7!==peg$FAILED) {
        peg$savedPos = p8;
        r7 = peg$a6(r4, r5, r11, r12);
        break choice_2;
      }
      seq_3: {
      p9 = peg$currPos;
      p13 = peg$currPos;
      choice_3: {
      r14 = input.substr(peg$currPos,4);
      if (r14.toLowerCase() === "&lt;") {
        peg$currPos += 4;
        break choice_3;
      } else {
        r14 = peg$FAILED;
      }
      r14 = input.substr(peg$currPos,4);
      if (r14.toLowerCase() === "&gt;") {
        peg$currPos += 4;
      } else {
        r14 = peg$FAILED;
      }
      } // choice_3
      if (r14 === peg$FAILED) {
        r14 = void 0;
      } else {
        r14 = peg$FAILED;
        peg$currPos = p13;
        r7 = peg$FAILED;
        break seq_3;
      }
      // free p13
      choice_4: {
      seq_4: {
      p13 = peg$currPos;
      p16 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r17 = "&";
        peg$currPos += 1;
        r17 = void 0;
        peg$currPos = p16;
      } else {
        r17 = peg$FAILED;
        r15 = peg$FAILED;
        break seq_4;
      }
      // free p16
      r18 = peg$parsehtmlentity(true);
      if (r18===peg$FAILED) {
        peg$currPos = p13;
        r15 = peg$FAILED;
        break seq_4;
      }
      r15 = [r17,r18];
      } // seq_4
      if (r15!==peg$FAILED) {
        break choice_4;
      }
      // free p13
      if (input.charCodeAt(peg$currPos) === 38) {
        r15 = "&";
        peg$currPos += 1;
      } else {
        r15 = peg$FAILED;
      }
      } // choice_4
      // r <- r15
      if (r15===peg$FAILED) {
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_3;
      }
      r7 = [r14,r15];
      } // seq_3
      // free p9
      } // choice_2
      if (r7!==peg$FAILED) {
        r6.push(r7);
      } else {
        break;
      }
    }
    // path <- r6
    // free r7
    peg$savedPos = peg$currPos;
    r7 = peg$a7(r4, r5, r6);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a8(r4, r5, r6);
    } else {
      if (!silence) {peg$fail(peg$c3);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [194,boolParams & 0x3bbf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsetable_attributes(silence, boolParams | 0x40, param_templatedepth, param_preproc, param_th);
    // as <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parseoptional_spaces(silence);
    // s <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsepipe(silence);
    // p <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r8 = peg$discardpipe(true);
    if (r8 === peg$FAILED) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a9(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attributes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [6,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      choice_1: {
      r2 = peg$parsetable_attribute(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      r2 = peg$parsebroken_table_attribute(true);
      } // choice_1
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsegeneric_newline_attributes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [4,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      r2 = peg$parsegeneric_newline_attribute(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetplarg_or_template_or_bust(silence, param_preproc) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [62,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parsetplarg_or_template(true, 0x0, 0, new peg$Reference(null), param_preproc);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      if (peg$currPos < input.length) {
        r4 = input.charAt(peg$currPos++);
      } else {
        r4 = peg$FAILED;
      }
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a10(r3);
    } else {
      if (!silence) {peg$fail(peg$c6);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4,p5,p6,r7,r8,r9,p10,r11,r12,r13,r14,r15,r16,r17,r18,r19,r20;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [44,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    if (!(/*extlink*/(boolParams & 0x4) !== 0)) {
      r3 = void 0;
    } else {
      r3 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r7 = "[";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      r4 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$parseurl_protocol(true);
    if (r11===peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    choice_2: {
    r12 = peg$parseIPAddress(true);
    if (r12!==peg$FAILED) {
      break choice_2;
    }
    r12 = '';
    } // choice_2
    if (r12===peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    r13 = peg$parseextlink_preprocessor_text(true, boolParams | 0x4, param_templatedepth, param_preproc, param_th);
    if (r13===peg$FAILED) {
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    r9 = [r11,r12,r13];
    } // seq_3
    // literal <- r9
    // free p10
    r8 = r9;
    if (r8!==peg$FAILED) {
      break choice_1;
    }
    choice_3: {
    r15 = peg$parseextlink_preprocessor_text(true, boolParams | 0x4, param_templatedepth, param_preproc, param_th);
    // p <- r15
    r14 = r15;
    if (r14!==peg$FAILED) {
      break choice_3;
    }
    seq_4: {
    p10 = peg$currPos;
    peg$savedPos = peg$currPos;
    r16 = peg$a11(r9, r15);
    if (r16) {
      r16 = void 0;
    } else {
      r16 = peg$FAILED;
      peg$currPos = p10;
      r14 = peg$FAILED;
      break seq_4;
    }
    r14 = ['',r16];
    } // seq_4
    // free p10
    } // choice_3
    // parameterized <- r14
    r8 = r14;
    } // choice_1
    // addr <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    p10 = peg$currPos;
    for (;;) {
      choice_4: {
      r18 = peg$discardspace(true);
      if (r18!==peg$FAILED) {
        break choice_4;
      }
      r18 = peg$discardunispace(true);
      } // choice_4
      if (r18===peg$FAILED) {
        break;
      }
    }
    // free r18
    r17 = true;
    // sp <- r17
    if (r17!==peg$FAILED) {
      r17 = input.substring(p10, peg$currPos);
    } else {
      r17 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    // free p10
    p10 = peg$currPos;
    r18 = '';
    // targetOff <- r18
    if (r18!==peg$FAILED) {
      peg$savedPos = p10;
      r18 = peg$a12(r8, r17);
    } else {
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r19 = peg$parseinlineline(true, boolParams | 0x4, param_templatedepth, param_preproc, param_th);
    if (r19===peg$FAILED) {
      r19 = null;
    }
    // content <- r19
    if (input.charCodeAt(peg$currPos) === 93) {
      r20 = "]";
      peg$currPos += 1;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    // r <- r4
    if (r4!==peg$FAILED) {
      peg$savedPos = p5;
      r4 = peg$a13(r8, r17, r18, r19);
    } else {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r2 = [r3,r4];
    } // seq_1
    if (r2===peg$FAILED) {
      if (!silence) {peg$fail(peg$c7);}
    }
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parsetlb(silence, param_preproc) {
    var r1,p2,p3,p4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [10,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardeof(true);
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseblock(true, 0x0, 0, new peg$Reference(null), param_preproc);
    // b <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a14(r6);
    } else {
      if (!silence) {peg$fail(peg$c8);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsenewlineToken(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 246;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r1 = peg$discardnewline(silence);
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a15();
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardtlb(silence, param_preproc) {
    var r1,p2,p3,p4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [11,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardeof(true);
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseblock(true, 0x0, 0, new peg$Reference(null), param_preproc);
    // b <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a14(r6);
    } else {
      if (!silence) {peg$fail(peg$c8);}
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$discardnewlineToken(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 247;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r1 = peg$discardnewline(silence);
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a15();
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsespace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 210;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c9);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsecomment(silence) {
    var r1,p2,p3,r4,r5,p6,r7,p8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 36;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "<!--") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c10);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      seq_2: {
      p8 = peg$currPos;
      p9 = peg$currPos;
      r10 = input.substr(peg$currPos,3);
      if (r10 === "-->") {
        peg$currPos += 3;
      } else {
        r10 = peg$FAILED;
      }
      if (r10 === peg$FAILED) {
        r10 = void 0;
      } else {
        r10 = peg$FAILED;
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p9
      if (peg$currPos < input.length) {
        r11 = input.charAt(peg$currPos++);
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p8;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7===peg$FAILED) {
        break;
      }
      // free p8
    }
    // free r7
    r5 = true;
    // c <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    choice_1: {
    r7 = input.substr(peg$currPos,3);
    if (r7 === "-->") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c12);}
      r7 = peg$FAILED;
    }
    r7 = peg$discardeof(silence);
    } // choice_1
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a16(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsepipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 272;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r1 = "|";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c13);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1 === "{{!}}") {
      peg$currPos += 5;
    } else {
      if (!silence) {peg$fail(peg$c14);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseurl_protocol(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 50;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = input.substr(peg$currPos,8);
    if (r1.toLowerCase() === "bitcoin:") {
      peg$currPos += 8;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c15);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,6);
    if (r1.toLowerCase() === "ftp://") {
      peg$currPos += 6;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c16);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,7);
    if (r1.toLowerCase() === "ftps://") {
      peg$currPos += 7;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c17);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,4);
    if (r1.toLowerCase() === "geo:") {
      peg$currPos += 4;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c18);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,6);
    if (r1.toLowerCase() === "git://") {
      peg$currPos += 6;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c19);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,9);
    if (r1.toLowerCase() === "gopher://") {
      peg$currPos += 9;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c20);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,7);
    if (r1.toLowerCase() === "http://") {
      peg$currPos += 7;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c21);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,8);
    if (r1.toLowerCase() === "https://") {
      peg$currPos += 8;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c22);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,6);
    if (r1.toLowerCase() === "irc://") {
      peg$currPos += 6;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c23);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,7);
    if (r1.toLowerCase() === "ircs://") {
      peg$currPos += 7;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c24);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,7);
    if (r1.toLowerCase() === "magnet:") {
      peg$currPos += 7;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c25);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,7);
    if (r1.toLowerCase() === "mailto:") {
      peg$currPos += 7;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c26);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,6);
    if (r1.toLowerCase() === "mms://") {
      peg$currPos += 6;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c27);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1.toLowerCase() === "news:") {
      peg$currPos += 5;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c28);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,7);
    if (r1.toLowerCase() === "nntp://") {
      peg$currPos += 7;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c29);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,8);
    if (r1.toLowerCase() === "redis://") {
      peg$currPos += 8;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c30);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,7);
    if (r1.toLowerCase() === "sftp://") {
      peg$currPos += 7;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c31);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,4);
    if (r1.toLowerCase() === "sip:") {
      peg$currPos += 4;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c32);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1.toLowerCase() === "sips:") {
      peg$currPos += 5;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c33);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,4);
    if (r1.toLowerCase() === "sms:") {
      peg$currPos += 4;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c34);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,6);
    if (r1.toLowerCase() === "ssh://") {
      peg$currPos += 6;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c35);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,6);
    if (r1.toLowerCase() === "svn://") {
      peg$currPos += 6;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c36);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,4);
    if (r1.toLowerCase() === "tel:") {
      peg$currPos += 4;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c37);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,9);
    if (r1.toLowerCase() === "telnet://") {
      peg$currPos += 9;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c38);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,4);
    if (r1.toLowerCase() === "urn:") {
      peg$currPos += 4;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c39);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,12);
    if (r1.toLowerCase() === "worldwind://") {
      peg$currPos += 12;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c40);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1.toLowerCase() === "xmpp:") {
      peg$currPos += 5;
    } else {
      if (!silence) {peg$fail(peg$c41);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseIPAddress(silence) {
    var p1,r2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 56;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r4 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$FAILED;
    for (;;) {
      r6 = input.charAt(peg$currPos);
      if (/^[0-9A-Fa-f:.]/.test(r6)) {
        peg$currPos++;
        r5 = true;
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c43);}
        break;
      }
    }
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r6
    if (input.charCodeAt(peg$currPos) === 93) {
      r6 = "]";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c44);}
      r6 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [29,boolParams & 0x1bfe,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[=|!{}:;\r\n[\]\-]/.test(r4)) {
      peg$currPos++;
      r4 = void 0;
      peg$currPos = p3;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free p3
    seq_2: {
    p3 = peg$currPos;
    peg$savedPos = peg$currPos;
    r6 = peg$a17(/*extTag*/(boolParams & 0x800) !== 0, /*h*/(boolParams & 0x2) !== 0, /*extlink*/(boolParams & 0x4) !== 0, param_templatedepth, param_preproc.value, /*equal*/(boolParams & 0x8) !== 0, /*table*/(boolParams & 0x10) !== 0, /*templateArg*/(boolParams & 0x20) !== 0, /*tableCellArg*/(boolParams & 0x40) !== 0, /*semicolon*/(boolParams & 0x80) !== 0, /*arrow*/(boolParams & 0x100) !== 0, /*linkdesc*/(boolParams & 0x200) !== 0, /*colon*/(boolParams & 0x1000) !== 0, param_th.value);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r5,p3
    r2 = true;
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [58,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "{{") {
      peg$currPos += 2;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    peg$savedPos = peg$currPos;
    r6 = peg$a18(param_templatedepth);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetplarg_or_template_guarded(silence, boolParams, param_templatedepth + 1, param_th, param_preproc);
    // t <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a19(param_templatedepth, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsehtmlentity(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 204;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseraw_htmlentity(silence);
    // cc <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a20(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseoptional_spaces(silence) {
    var p1,r2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 208;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    for (;;) {
      r3 = input.charAt(peg$currPos);
      if (/^[ \t]/.test(r3)) {
        peg$currPos++;
      } else {
        r3 = peg$FAILED;
        if (!silence) {peg$fail(peg$c9);}
        break;
      }
    }
    // free r3
    r2 = true;
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$discardpipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 273;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 124) {
      r1 = "|";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c13);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,5);
    if (r1 === "{{!}}") {
      peg$currPos += 5;
    } else {
      if (!silence) {peg$fail(peg$c14);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetable_attribute(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,p11,p12,r13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [196,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseoptionalSpaceToken(silence);
    // s <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // namePos0 <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a21(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetable_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // name <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p9 = peg$currPos;
    r8 = '';
    // namePos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a22(r4, r5, r7);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p11 = peg$currPos;
    seq_2: {
    p12 = peg$currPos;
    r13 = peg$discardoptionalSpaceToken(silence);
    if (r13===peg$FAILED) {
      r10 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 61) {
      r14 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c45);}
      r14 = peg$FAILED;
      peg$currPos = p12;
      r10 = peg$FAILED;
      break seq_2;
    }
    r15 = peg$parsetable_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // v <- r15
    r10 = true;
    } // seq_2
    if (r10!==peg$FAILED) {
      peg$savedPos = p11;
      r10 = peg$a23(r4, r5, r7, r8, r15);
    } else {
      r10 = null;
    }
    // free p12
    // vd <- r10
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a24(r4, r5, r7, r8, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebroken_table_attribute(silence) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 198;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$discardoptionalSpaceToken(silence);
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = input.charAt(peg$currPos);
    // c <- r5
    if (/^[\0\/=>]/.test(r5)) {
      peg$currPos++;
    } else {
      r5 = peg$FAILED;
      if (!silence) {peg$fail(peg$c46);}
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a25(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsegeneric_newline_attribute(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,p8,r9,p10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [142,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    for (;;) {
      r5 = peg$discardspace_or_newline_or_solidus(silence);
      if (r5===peg$FAILED) {
        break;
      }
    }
    // free r5
    r4 = true;
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r4
    p6 = peg$currPos;
    r4 = '';
    // namePos0 <- r4
    if (r4!==peg$FAILED) {
      peg$savedPos = p6;
      r4 = peg$a26();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsegeneric_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // name <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p8 = peg$currPos;
    r7 = '';
    // namePos <- r7
    if (r7!==peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$a27(r4, r5);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p10 = peg$currPos;
    seq_2: {
    p11 = peg$currPos;
    for (;;) {
      r13 = peg$discardspace_or_newline(silence);
      if (r13===peg$FAILED) {
        break;
      }
    }
    // free r13
    r12 = true;
    if (r12===peg$FAILED) {
      r9 = peg$FAILED;
      break seq_2;
    }
    // free r12
    if (input.charCodeAt(peg$currPos) === 61) {
      r12 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c45);}
      r12 = peg$FAILED;
      peg$currPos = p11;
      r9 = peg$FAILED;
      break seq_2;
    }
    r13 = peg$parsegeneric_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r13===peg$FAILED) {
      r13 = null;
    }
    // v <- r13
    r9 = true;
    } // seq_2
    if (r9!==peg$FAILED) {
      peg$savedPos = p10;
      r9 = peg$a28(r4, r5, r7, r13);
    } else {
      r9 = null;
    }
    // free p11
    // vd <- r9
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a29(r4, r5, r7, r9);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseextlink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [256,boolParams & 0x39ff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parseextlink_preprocessor_text_parameterized(silence, boolParams & ~0x200, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardspace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 211;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c9);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardunispace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 219;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c47);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,p6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [30,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parseurltext(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      seq_1: {
      p5 = peg$currPos;
      p6 = peg$currPos;
      r7 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r7 === peg$FAILED) {
        r7 = void 0;
      } else {
        r7 = peg$FAILED;
        peg$currPos = p6;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p6
      choice_2: {
      r8 = peg$parseinline_element(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8!==peg$FAILED) {
        break choice_2;
      }
      r8 = input.charAt(peg$currPos);
      if (/^[^\r\n]/.test(r8)) {
        peg$currPos++;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c48);}
      }
      } // choice_2
      // r <- r8
      if (r8===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r7,r8];
      } // seq_1
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // c <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a30(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardeof(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 243;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    peg$savedPos = peg$currPos;
    r1 = peg$a31();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseblock(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,r6,r7,r8,p9,r10,r11,p12,r13,p14,r15,r16,r17,r18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [12,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardsof(true);
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseredirect(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // r <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsecomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // cil <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parseblock_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // bl <- r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a32(r6, r7, r8);
      break choice_1;
    }
    // free p3
    r1 = peg$parseblock_lines(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p3 = peg$currPos;
    seq_2: {
    p4 = peg$currPos;
    p9 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r10 = "<";
      peg$currPos += 1;
      r10 = void 0;
      peg$currPos = p9;
    } else {
      r10 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p9
    choice_2: {
    p9 = peg$currPos;
    seq_3: {
    p12 = peg$currPos;
    r13 = peg$parsecomment(silence);
    // c <- r13
    if (r13===peg$FAILED) {
      r11 = peg$FAILED;
      break seq_3;
    }
    p14 = peg$currPos;
    r15 = peg$discardeolf(true);
    if (r15!==peg$FAILED) {
      r15 = void 0;
      peg$currPos = p14;
    } else {
      peg$currPos = p12;
      r11 = peg$FAILED;
      break seq_3;
    }
    // free p14
    r11 = true;
    } // seq_3
    if (r11!==peg$FAILED) {
      peg$savedPos = p9;
      r11 = peg$a33(r13);
      break choice_2;
    }
    // free p12
    r16 = peg$parseblock_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // bt <- r16
    r11 = r16;
    } // choice_2
    // rs <- r11
    if (r11===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a34(r11);
      break choice_1;
    }
    // free p4
    r1 = peg$parseparagraph(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p4 = peg$currPos;
    seq_4: {
    p12 = peg$currPos;
    r17 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s <- r17
    if (r17===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_4;
    }
    p14 = peg$currPos;
    r18 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r18 === peg$FAILED) {
      r18 = void 0;
    } else {
      r18 = peg$FAILED;
      peg$currPos = p14;
      peg$currPos = p12;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p14
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a35(r17);
    }
    // free p12
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$discardnewline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 245;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 10) {
      r1 = "\n";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c49);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,2);
    if (r1 === "\r\n") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetplarg_or_template_guarded(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,p6,r7,p8,r9,p10,r11,r12,p13,r14,r15,r16,r17,r18,r19,r20,p21,r22,r23,r24,r25,r26,p27,r28,r29,r30;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [60,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = input.substr(peg$currPos,2);
    if (r7 === "{{") {
      peg$currPos += 2;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    p8 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$FAILED;
    for (;;) {
      r12 = input.substr(peg$currPos,3);
      if (r12 === "{{{") {
        peg$currPos += 3;
        r11 = true;
      } else {
        r12 = peg$FAILED;
        break;
      }
    }
    if (r11===peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    // free r12
    p13 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r12 = "{";
      peg$currPos += 1;
    } else {
      r12 = peg$FAILED;
    }
    if (r12 === peg$FAILED) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p13;
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    // free p13
    r9 = true;
    } // seq_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p8;
    } else {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free p10
    // free p8
    r14 = peg$discardtplarg(true, boolParams, param_templatedepth, param_th);
    if (r14===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    choice_2: {
    r15 = peg$parsetemplate(silence, boolParams, param_templatedepth, param_th);
    if (r15!==peg$FAILED) {
      break choice_2;
    }
    r15 = peg$parsebroken_template(silence, param_preproc);
    } // choice_2
    // a <- r15
    if (r15===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a36(r15);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p4 = peg$currPos;
    p6 = peg$currPos;
    seq_5: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r17 = "{";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c51);}
      r17 = peg$FAILED;
      r16 = peg$FAILED;
      break seq_5;
    }
    p10 = peg$currPos;
    seq_6: {
    p13 = peg$currPos;
    r19 = peg$FAILED;
    for (;;) {
      r20 = input.substr(peg$currPos,3);
      if (r20 === "{{{") {
        peg$currPos += 3;
        r19 = true;
      } else {
        r20 = peg$FAILED;
        break;
      }
    }
    if (r19===peg$FAILED) {
      r18 = peg$FAILED;
      break seq_6;
    }
    // free r20
    p21 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r20 = "{";
      peg$currPos += 1;
    } else {
      r20 = peg$FAILED;
    }
    if (r20 === peg$FAILED) {
      r20 = void 0;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p21;
      peg$currPos = p13;
      r18 = peg$FAILED;
      break seq_6;
    }
    // free p21
    r18 = true;
    } // seq_6
    if (r18!==peg$FAILED) {
      r18 = void 0;
      peg$currPos = p10;
    } else {
      peg$currPos = p8;
      r16 = peg$FAILED;
      break seq_5;
    }
    // free p13
    // free p10
    r16 = true;
    } // seq_5
    if (r16===peg$FAILED) {
      r16 = null;
    }
    // free p8
    // a <- r16
    r16 = input.substring(p6, peg$currPos);
    // free p6
    r22 = peg$parsetplarg(silence, boolParams, param_templatedepth, param_th);
    // b <- r22
    if (r22===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a37(r16, r22);
      break choice_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_7: {
    p6 = peg$currPos;
    p8 = peg$currPos;
    seq_8: {
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r24 = "{";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c51);}
      r24 = peg$FAILED;
      r23 = peg$FAILED;
      break seq_8;
    }
    p13 = peg$currPos;
    seq_9: {
    p21 = peg$currPos;
    r26 = input.substr(peg$currPos,2);
    if (r26 === "{{") {
      peg$currPos += 2;
    } else {
      r26 = peg$FAILED;
      r25 = peg$FAILED;
      break seq_9;
    }
    p27 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r28 = "{";
      peg$currPos += 1;
    } else {
      r28 = peg$FAILED;
    }
    if (r28 === peg$FAILED) {
      r28 = void 0;
    } else {
      r28 = peg$FAILED;
      peg$currPos = p27;
      peg$currPos = p21;
      r25 = peg$FAILED;
      break seq_9;
    }
    // free p27
    r25 = true;
    } // seq_9
    if (r25!==peg$FAILED) {
      r25 = void 0;
      peg$currPos = p13;
    } else {
      peg$currPos = p10;
      r23 = peg$FAILED;
      break seq_8;
    }
    // free p21
    // free p13
    r23 = true;
    } // seq_8
    if (r23===peg$FAILED) {
      r23 = null;
    }
    // free p10
    // a <- r23
    r23 = input.substring(p8, peg$currPos);
    // free p8
    r29 = peg$parsetemplate(silence, boolParams, param_templatedepth, param_th);
    // b <- r29
    if (r29===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    r1 = true;
    } // seq_7
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a37(r23, r29);
      break choice_1;
    }
    // free p6
    p6 = peg$currPos;
    r30 = peg$parsebroken_template(silence, param_preproc);
    // a <- r30
    r1 = r30;
    if (r1!==peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$a36(r30);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parseraw_htmlentity(silence) {
    var r1,p2,r3,p4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 202;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r6 = "&";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c52);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$FAILED;
    for (;;) {
      r8 = input.charAt(peg$currPos);
      if (/^[#0-9a-zA-Z]/.test(r8)) {
        peg$currPos++;
        r7 = true;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c53);}
        break;
      }
    }
    if (r7===peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free r8
    if (input.charCodeAt(peg$currPos) === 59) {
      r8 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c54);}
      r8 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    // encoded <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a38(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseoptionalSpaceToken(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 212;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseoptional_spaces(silence);
    // s <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a39(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetable_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,p9,r10,p11,r12,r13,p14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [148,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^["'=]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c55);}
      r4 = null;
    }
    // q <- r4
    r4 = input.substring(p5, peg$currPos);
    // free p5
    r6 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r7 = peg$FAILED;
      for (;;) {
        r8 = input.charAt(peg$currPos);
        if (/^[^ \t\r\n\0\/=><&{}\-!|[]/.test(r8)) {
          peg$currPos++;
          r7 = true;
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c56);}
          break;
        }
      }
      if (r7!==peg$FAILED) {
        r7 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r7 = peg$FAILED;
      }
      // free r8
      // free p5
      seq_2: {
      p5 = peg$currPos;
      p9 = peg$currPos;
      r8 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p9
      choice_2: {
      p9 = peg$currPos;
      r10 = peg$discardwikilink(silence, boolParams, param_templatedepth, param_th, param_preproc);
      if (r10!==peg$FAILED) {
        r10 = input.substring(p9, peg$currPos);
        break choice_2;
      } else {
        r10 = peg$FAILED;
      }
      // free p9
      r10 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      seq_3: {
      p9 = peg$currPos;
      p11 = peg$currPos;
      r12 = peg$discardxmlish_tag(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r12!==peg$FAILED) {
        r12 = void 0;
        peg$currPos = p11;
      } else {
        r10 = peg$FAILED;
        break seq_3;
      }
      // free p11
      r13 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r13===peg$FAILED) {
        peg$currPos = p9;
        r10 = peg$FAILED;
        break seq_3;
      }
      r10 = [r12,r13];
      } // seq_3
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      // free p9
      p9 = peg$currPos;
      seq_4: {
      p11 = peg$currPos;
      p14 = peg$currPos;
      choice_3: {
      r15 = peg$discardspace_or_newline(true);
      if (r15!==peg$FAILED) {
        break choice_3;
      }
      r15 = input.charAt(peg$currPos);
      if (/^[\0\/=>]/.test(r15)) {
        peg$currPos++;
      } else {
        r15 = peg$FAILED;
      }
      } // choice_3
      if (r15 === peg$FAILED) {
        r15 = void 0;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p14;
        r10 = peg$FAILED;
        break seq_4;
      }
      // free p14
      if (peg$currPos < input.length) {
        r16 = input.charAt(peg$currPos++);
      } else {
        r16 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p11;
        r10 = peg$FAILED;
        break seq_4;
      }
      r10 = true;
      } // seq_4
      if (r10!==peg$FAILED) {
        r10 = input.substring(p9, peg$currPos);
      } else {
        r10 = peg$FAILED;
      }
      // free p11
      // free p9
      } // choice_2
      if (r10===peg$FAILED) {
        peg$currPos = p5;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = [r8,r10];
      } // seq_2
      // free p5
      } // choice_1
      if (r7!==peg$FAILED) {
        r6.push(r7);
      } else {
        break;
      }
    }
    // r <- r6
    // free r7
    peg$savedPos = peg$currPos;
    r7 = peg$a40(r4, r6);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a41(r4, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardoptionalSpaceToken(silence) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 213;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseoptional_spaces(silence);
    // s <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a39(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetable_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,p6,r7,r8,r9,r10,p11,r12,r13,r14,r15,r16,r17;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [152,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    if (r7===peg$FAILED) {
      r4 = peg$FAILED;
      break seq_2;
    }
    // free r7
    if (input.charCodeAt(peg$currPos) === 39) {
      r7 = "'";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c57);}
      r7 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    // s <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p5
    r8 = peg$parsetable_attribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // t <- r8
    p5 = peg$currPos;
    choice_2: {
    if (input.charCodeAt(peg$currPos) === 39) {
      r9 = "'";
      peg$currPos += 1;
      break choice_2;
    } else {
      if (!silence) {peg$fail(peg$c57);}
      r9 = peg$FAILED;
    }
    p6 = peg$currPos;
    choice_3: {
    r9 = input.substr(peg$currPos,2);
    if (r9 === "!!") {
      peg$currPos += 2;
      break choice_3;
    } else {
      r9 = peg$FAILED;
    }
    r9 = input.charAt(peg$currPos);
    if (/^[|\r\n]/.test(r9)) {
      peg$currPos++;
    } else {
      r9 = peg$FAILED;
    }
    } // choice_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p6;
    }
    // free p6
    } // choice_2
    // q <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p5, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a42(r4, r8, r9);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_3: {
    p5 = peg$currPos;
    p6 = peg$currPos;
    seq_4: {
    p11 = peg$currPos;
    for (;;) {
      r13 = peg$discardspace(silence);
      if (r13===peg$FAILED) {
        break;
      }
    }
    // free r13
    r12 = true;
    if (r12===peg$FAILED) {
      r10 = peg$FAILED;
      break seq_4;
    }
    // free r12
    if (input.charCodeAt(peg$currPos) === 34) {
      r12 = "\"";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c58);}
      r12 = peg$FAILED;
      peg$currPos = p11;
      r10 = peg$FAILED;
      break seq_4;
    }
    r10 = true;
    } // seq_4
    // s <- r10
    if (r10!==peg$FAILED) {
      r10 = input.substring(p6, peg$currPos);
    } else {
      r10 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    // free p11
    // free p6
    r13 = peg$parsetable_attribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r13===peg$FAILED) {
      r13 = null;
    }
    // t <- r13
    p6 = peg$currPos;
    choice_4: {
    if (input.charCodeAt(peg$currPos) === 34) {
      r14 = "\"";
      peg$currPos += 1;
      break choice_4;
    } else {
      if (!silence) {peg$fail(peg$c58);}
      r14 = peg$FAILED;
    }
    p11 = peg$currPos;
    choice_5: {
    r14 = input.substr(peg$currPos,2);
    if (r14 === "!!") {
      peg$currPos += 2;
      break choice_5;
    } else {
      r14 = peg$FAILED;
    }
    r14 = input.charAt(peg$currPos);
    if (/^[|\r\n]/.test(r14)) {
      peg$currPos++;
    } else {
      r14 = peg$FAILED;
    }
    } // choice_5
    if (r14!==peg$FAILED) {
      r14 = void 0;
      peg$currPos = p11;
    }
    // free p11
    } // choice_4
    // q <- r14
    if (r14!==peg$FAILED) {
      r14 = input.substring(p6, peg$currPos);
    } else {
      r14 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_3;
    }
    // free p6
    r1 = true;
    } // seq_3
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a42(r10, r13, r14);
      break choice_1;
    }
    // free p5
    p5 = peg$currPos;
    seq_5: {
    p6 = peg$currPos;
    p11 = peg$currPos;
    for (;;) {
      r16 = peg$discardspace(silence);
      if (r16===peg$FAILED) {
        break;
      }
    }
    // free r16
    r15 = true;
    // s <- r15
    if (r15!==peg$FAILED) {
      r15 = input.substring(p11, peg$currPos);
    } else {
      r15 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_5;
    }
    // free p11
    r16 = peg$parsetable_attribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // t <- r16
    if (r16===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_5;
    }
    p11 = peg$currPos;
    choice_6: {
    r17 = peg$discardspace_or_newline(true);
    if (r17!==peg$FAILED) {
      break choice_6;
    }
    r17 = peg$discardeof(true);
    if (r17!==peg$FAILED) {
      break choice_6;
    }
    r17 = input.substr(peg$currPos,2);
    if (r17 === "!!") {
      peg$currPos += 2;
      break choice_6;
    } else {
      r17 = peg$FAILED;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r17 = "|";
      peg$currPos += 1;
    } else {
      r17 = peg$FAILED;
    }
    } // choice_6
    if (r17!==peg$FAILED) {
      r17 = void 0;
      peg$currPos = p11;
    } else {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_5;
    }
    // free p11
    r1 = true;
    } // seq_5
    if (r1!==peg$FAILED) {
      peg$savedPos = p5;
      r1 = peg$a43(r15, r16);
    }
    // free p6
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardspace_or_newline_or_solidus(silence) {
    var r1,p2,r3,p4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 135;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardspace_or_newline(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    seq_1: {
    p2 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r3 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c59);}
      r3 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 62) {
      r5 = ">";
      peg$currPos += 1;
    } else {
      r5 = peg$FAILED;
    }
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r1 = true;
    } // seq_1
    // free p2
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsegeneric_attribute_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,p9,r10,p11,p12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [146,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^["'=]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c55);}
      r4 = null;
    }
    // q <- r4
    r4 = input.substring(p5, peg$currPos);
    // free p5
    r6 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r7 = peg$FAILED;
      for (;;) {
        r8 = input.charAt(peg$currPos);
        if (/^[^ \t\r\n\0\/=><&{}\-!|]/.test(r8)) {
          peg$currPos++;
          r7 = true;
        } else {
          r8 = peg$FAILED;
          if (!silence) {peg$fail(peg$c60);}
          break;
        }
      }
      if (r7!==peg$FAILED) {
        r7 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r7 = peg$FAILED;
      }
      // free r8
      // free p5
      seq_2: {
      p5 = peg$currPos;
      p9 = peg$currPos;
      r8 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p9
      choice_2: {
      r10 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      r10 = peg$parseless_than(silence, boolParams);
      if (r10!==peg$FAILED) {
        break choice_2;
      }
      p9 = peg$currPos;
      seq_3: {
      p11 = peg$currPos;
      p12 = peg$currPos;
      choice_3: {
      r13 = peg$discardspace_or_newline(true);
      if (r13!==peg$FAILED) {
        break choice_3;
      }
      r13 = input.charAt(peg$currPos);
      if (/^[\0\/=><]/.test(r13)) {
        peg$currPos++;
      } else {
        r13 = peg$FAILED;
      }
      } // choice_3
      if (r13 === peg$FAILED) {
        r13 = void 0;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p12;
        r10 = peg$FAILED;
        break seq_3;
      }
      // free p12
      if (peg$currPos < input.length) {
        r14 = input.charAt(peg$currPos++);
      } else {
        r14 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p11;
        r10 = peg$FAILED;
        break seq_3;
      }
      r10 = true;
      } // seq_3
      if (r10!==peg$FAILED) {
        r10 = input.substring(p9, peg$currPos);
      } else {
        r10 = peg$FAILED;
      }
      // free p11
      // free p9
      } // choice_2
      if (r10===peg$FAILED) {
        peg$currPos = p5;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = [r8,r10];
      } // seq_2
      // free p5
      } // choice_1
      if (r7!==peg$FAILED) {
        r6.push(r7);
      } else {
        break;
      }
    }
    // r <- r6
    // free r7
    peg$savedPos = peg$currPos;
    r7 = peg$a40(r4, r6);
    if (r7) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a41(r4, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardspace_or_newline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 215;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \t\n\r\f]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c61);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsegeneric_att_value(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,p6,r7,r8,r9,p10,r11,r12,r13,r14,r15,r16,p17,r18,r19,r20,r21,r22,r23,r24;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [150,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace_or_newline(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    if (r7===peg$FAILED) {
      r4 = peg$FAILED;
      break seq_2;
    }
    // free r7
    if (input.charCodeAt(peg$currPos) === 39) {
      r7 = "'";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c57);}
      r7 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    // s <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p5
    r8 = peg$parseattribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // t <- r8
    p5 = peg$currPos;
    choice_2: {
    if (input.charCodeAt(peg$currPos) === 39) {
      r9 = "'";
      peg$currPos += 1;
      break choice_2;
    } else {
      if (!silence) {peg$fail(peg$c57);}
      r9 = peg$FAILED;
    }
    p6 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r11 = "/";
      peg$currPos += 1;
    } else {
      r11 = peg$FAILED;
      r11 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r12 = ">";
      peg$currPos += 1;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    r9 = true;
    } // seq_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p6;
    }
    // free p10
    // free p6
    } // choice_2
    // q <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p5, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a42(r4, r8, r9);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p5 = peg$currPos;
    p6 = peg$currPos;
    seq_5: {
    p10 = peg$currPos;
    for (;;) {
      r15 = peg$discardspace_or_newline(silence);
      if (r15===peg$FAILED) {
        break;
      }
    }
    // free r15
    r14 = true;
    if (r14===peg$FAILED) {
      r13 = peg$FAILED;
      break seq_5;
    }
    // free r14
    if (input.charCodeAt(peg$currPos) === 34) {
      r14 = "\"";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c58);}
      r14 = peg$FAILED;
      peg$currPos = p10;
      r13 = peg$FAILED;
      break seq_5;
    }
    r13 = true;
    } // seq_5
    // s <- r13
    if (r13!==peg$FAILED) {
      r13 = input.substring(p6, peg$currPos);
    } else {
      r13 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p10
    // free p6
    r15 = peg$parseattribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // t <- r15
    p6 = peg$currPos;
    choice_3: {
    if (input.charCodeAt(peg$currPos) === 34) {
      r16 = "\"";
      peg$currPos += 1;
      break choice_3;
    } else {
      if (!silence) {peg$fail(peg$c58);}
      r16 = peg$FAILED;
    }
    p10 = peg$currPos;
    seq_6: {
    p17 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r18 = "/";
      peg$currPos += 1;
    } else {
      r18 = peg$FAILED;
      r18 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r19 = ">";
      peg$currPos += 1;
    } else {
      r19 = peg$FAILED;
      peg$currPos = p17;
      r16 = peg$FAILED;
      break seq_6;
    }
    r16 = true;
    } // seq_6
    if (r16!==peg$FAILED) {
      r16 = void 0;
      peg$currPos = p10;
    }
    // free p17
    // free p10
    } // choice_3
    // q <- r16
    if (r16!==peg$FAILED) {
      r16 = input.substring(p6, peg$currPos);
    } else {
      r16 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p6
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a42(r13, r15, r16);
      break choice_1;
    }
    // free p5
    p5 = peg$currPos;
    seq_7: {
    p6 = peg$currPos;
    p10 = peg$currPos;
    for (;;) {
      r21 = peg$discardspace_or_newline(silence);
      if (r21===peg$FAILED) {
        break;
      }
    }
    // free r21
    r20 = true;
    // s <- r20
    if (r20!==peg$FAILED) {
      r20 = input.substring(p10, peg$currPos);
    } else {
      r20 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p10
    r21 = peg$parseattribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // t <- r21
    if (r21===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    p10 = peg$currPos;
    choice_4: {
    r22 = peg$discardspace_or_newline(true);
    if (r22!==peg$FAILED) {
      break choice_4;
    }
    r22 = peg$discardeof(true);
    if (r22!==peg$FAILED) {
      break choice_4;
    }
    seq_8: {
    p17 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r23 = "/";
      peg$currPos += 1;
    } else {
      r23 = peg$FAILED;
      r23 = null;
    }
    if (input.charCodeAt(peg$currPos) === 62) {
      r24 = ">";
      peg$currPos += 1;
    } else {
      r24 = peg$FAILED;
      peg$currPos = p17;
      r22 = peg$FAILED;
      break seq_8;
    }
    r22 = true;
    } // seq_8
    // free p17
    } // choice_4
    if (r22!==peg$FAILED) {
      r22 = void 0;
      peg$currPos = p10;
    } else {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p10
    r1 = true;
    } // seq_7
    if (r1!==peg$FAILED) {
      peg$savedPos = p5;
      r1 = peg$a43(r20, r21);
    }
    // free p6
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseextlink_preprocessor_text_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,p8,r9,r10,p11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [258,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{|!=&[\]'"<>\0- \uFFFD \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c62);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      p5 = peg$currPos;
      seq_1: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[{|!=]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c63);}
      }
      } // choice_2
      // s <- r9
      if (r9===peg$FAILED) {
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = true;
      } // seq_1
      if (r4!==peg$FAILED) {
        peg$savedPos = p5;
        r4 = peg$a35(r9);
        break choice_1;
      }
      // free p7
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        r10 = "'";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c57);}
        r10 = peg$FAILED;
        r4 = peg$FAILED;
        break seq_2;
      }
      p11 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        r12 = "'";
        peg$currPos += 1;
      } else {
        r12 = peg$FAILED;
      }
      if (r12 === peg$FAILED) {
        r12 = void 0;
      } else {
        r12 = peg$FAILED;
        peg$currPos = p11;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p11
      r4 = true;
      } // seq_2
      if (r4!==peg$FAILED) {
        r4 = input.substring(p7, peg$currPos);
      } else {
        r4 = peg$FAILED;
      }
      // free p8
      // free p7
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a44(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseurltext(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2,p3,p4,r5,r6,r7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [200,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      choice_1: {
      seq_1: {
      p3 = peg$currPos;
      p4 = peg$currPos;
      r5 = input.charAt(peg$currPos);
      if (/^[A-Za-z]/.test(r5)) {
        peg$currPos++;
        r5 = void 0;
        peg$currPos = p4;
      } else {
        r5 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_1;
      }
      // free p4
      r6 = peg$parseautolink(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6===peg$FAILED) {
        peg$currPos = p3;
        r2 = peg$FAILED;
        break seq_1;
      }
      r2 = [r5,r6];
      } // seq_1
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      // free p3
      seq_2: {
      p3 = peg$currPos;
      p4 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r7 = "&";
        peg$currPos += 1;
        r7 = void 0;
        peg$currPos = p4;
      } else {
        r7 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_2;
      }
      // free p4
      r8 = peg$parsehtmlentity(silence);
      if (r8===peg$FAILED) {
        peg$currPos = p3;
        r2 = peg$FAILED;
        break seq_2;
      }
      r2 = [r7,r8];
      } // seq_2
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      // free p3
      seq_3: {
      p3 = peg$currPos;
      p4 = peg$currPos;
      r9 = input.substr(peg$currPos,2);
      if (r9 === "__") {
        peg$currPos += 2;
        r9 = void 0;
        peg$currPos = p4;
      } else {
        r9 = peg$FAILED;
        r2 = peg$FAILED;
        break seq_3;
      }
      // free p4
      r10 = peg$parsebehavior_switch(silence);
      if (r10===peg$FAILED) {
        peg$currPos = p3;
        r2 = peg$FAILED;
        break seq_3;
      }
      r2 = [r9,r10];
      } // seq_3
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      // free p3
      r2 = input.charAt(peg$currPos);
      if (/^[^\-'<~[{\n\r:;\]}|!=]/.test(r2)) {
        peg$currPos++;
      } else {
        r2 = peg$FAILED;
        if (!silence) {peg$fail(peg$c64);}
      }
      } // choice_1
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    if (r1.length === 0) {
      r1 = peg$FAILED;
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseinline_element(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7,r8,r9,r10,r11,p12,r13,r14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [32,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    seq_1: {
    p2 = peg$currPos;
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
      r4 = void 0;
      peg$currPos = p3;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p3
    choice_2: {
    r5 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_2;
    }
    r5 = peg$parsecomment(silence);
    } // choice_2
    // r <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = [r4,r5];
    } // seq_1
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    // free p2
    seq_2: {
    p2 = peg$currPos;
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r6 = "{";
      peg$currPos += 1;
      r6 = void 0;
      peg$currPos = p3;
    } else {
      r6 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p3
    r7 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // r <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = [r6,r7];
    } // seq_2
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    // free p2
    seq_3: {
    p2 = peg$currPos;
    p3 = peg$currPos;
    r8 = input.substr(peg$currPos,2);
    if (r8 === "-{") {
      peg$currPos += 2;
      r8 = void 0;
      peg$currPos = p3;
    } else {
      r8 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_3;
    }
    // free p3
    r9 = peg$parselang_variant_or_tpl(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // r <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_3;
    }
    r1 = [r8,r9];
    } // seq_3
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    // free p2
    p2 = peg$currPos;
    r1 = peg$FAILED;
    for (;;) {
      seq_4: {
      p3 = peg$currPos;
      r11 = input.substr(peg$currPos,2);
      if (r11 === "[[") {
        peg$currPos += 2;
      } else {
        if (!silence) {peg$fail(peg$c65);}
        r11 = peg$FAILED;
        r10 = peg$FAILED;
        break seq_4;
      }
      p12 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        r13 = "[";
        peg$currPos += 1;
        r13 = void 0;
        peg$currPos = p12;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p3;
        r10 = peg$FAILED;
        break seq_4;
      }
      // free p12
      r10 = true;
      } // seq_4
      if (r10!==peg$FAILED) {
        r1 = true;
      } else {
        break;
      }
      // free p3
    }
    if (r1!==peg$FAILED) {
      r1 = input.substring(p2, peg$currPos);
      break choice_1;
    } else {
      r1 = peg$FAILED;
    }
    // free r10
    // free p2
    seq_5: {
    p2 = peg$currPos;
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r10 = "[";
      peg$currPos += 1;
      r10 = void 0;
      peg$currPos = p3;
    } else {
      r10 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_5;
    }
    // free p3
    choice_3: {
    r14 = peg$parsewikilink(silence, boolParams, param_templatedepth, param_th, param_preproc);
    if (r14!==peg$FAILED) {
      break choice_3;
    }
    r14 = peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_3
    // r <- r14
    if (r14===peg$FAILED) {
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_5;
    }
    r1 = [r10,r14];
    } // seq_5
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    // free p2
    seq_6: {
    p2 = peg$currPos;
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      r15 = "'";
      peg$currPos += 1;
      r15 = void 0;
      peg$currPos = p3;
    } else {
      r15 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_6;
    }
    // free p3
    r16 = peg$parsequote(silence);
    // r <- r16
    if (r16===peg$FAILED) {
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_6;
    }
    r1 = [r15,r16];
    } // seq_6
    // free p2
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardsof(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 241;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    peg$savedPos = peg$currPos;
    r1 = peg$a45();
    if (r1) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseredirect(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,r4,p5,p6,r7,r8,r9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [2,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    for (;;) {
      r8 = input.charAt(peg$currPos);
      if (/^[ \t\n\r\0\x0B]/.test(r8)) {
        peg$currPos++;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c66);}
        break;
      }
    }
    // free r8
    r7 = true;
    if (r7===peg$FAILED) {
      r4 = peg$FAILED;
      break seq_2;
    }
    // free r7
    r7 = input.substr(peg$currPos,9);
    if (r7 === "#REDIRECT") {
      peg$currPos += 9;
    } else {
      if (!silence) {peg$fail(peg$c67);}
      r7 = peg$FAILED;
      peg$currPos = p6;
      r4 = peg$FAILED;
      break seq_2;
    }
    r4 = true;
    } // seq_2
    // rw <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p5
    p5 = peg$currPos;
    for (;;) {
      r9 = peg$discardspace_or_newline(silence);
      if (r9===peg$FAILED) {
        break;
      }
    }
    // free r9
    r8 = true;
    // sp <- r8
    if (r8!==peg$FAILED) {
      r8 = input.substring(p5, peg$currPos);
    } else {
      r8 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    p5 = peg$currPos;
    seq_3: {
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 58) {
      r10 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c68);}
      r10 = peg$FAILED;
      r9 = peg$FAILED;
      break seq_3;
    }
    for (;;) {
      r12 = peg$discardspace_or_newline(silence);
      if (r12===peg$FAILED) {
        break;
      }
    }
    // free r12
    r11 = true;
    if (r11===peg$FAILED) {
      peg$currPos = p6;
      r9 = peg$FAILED;
      break seq_3;
    }
    // free r11
    r9 = true;
    } // seq_3
    if (r9===peg$FAILED) {
      r9 = null;
    }
    // free p6
    // c <- r9
    r9 = input.substring(p5, peg$currPos);
    // free p5
    r11 = peg$parsewikilink(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // wl <- r11
    if (r11===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r12 = peg$a46(r4, r8, r9, r11);
    if (r12) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a47(r4, r8, r9, r11);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsecomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [226,boolParams & 0x13af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      choice_1: {
      r2 = peg$parsecomment(silence);
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      r2 = peg$parseinclude_limits(silence, boolParams | 0x2000, param_templatedepth, param_preproc, param_th);
      } // choice_1
      if (r2!==peg$FAILED) {
        r1.push(r2);
      } else {
        break;
      }
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseblock_line(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,p8,r9,r10,r11,r12,p13,p14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [22,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parseheading(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parselist_item(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsehr(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseoptionalSpaceToken(silence);
    // st <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    p8 = peg$currPos;
    r9 = input.charAt(peg$currPos);
    if (/^[ <{}|!]/.test(r9)) {
      peg$currPos++;
      r9 = void 0;
      peg$currPos = p8;
    } else {
      r9 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free p8
    r10 = peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // tl <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a48(r4, r10);
      break choice_2;
    }
    // free p7
    p7 = peg$currPos;
    seq_3: {
    p8 = peg$currPos;
    r11 = [];
    for (;;) {
      p13 = peg$currPos;
      seq_4: {
      p14 = peg$currPos;
      r15 = peg$parseblock_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // bt <- r15
      if (r15===peg$FAILED) {
        r12 = peg$FAILED;
        break seq_4;
      }
      r16 = peg$parseoptionalSpaceToken(silence);
      // stl <- r16
      if (r16===peg$FAILED) {
        peg$currPos = p14;
        r12 = peg$FAILED;
        break seq_4;
      }
      r12 = true;
      } // seq_4
      if (r12!==peg$FAILED) {
        peg$savedPos = p13;
        r12 = peg$a49(r4, r15, r16);
        r11.push(r12);
      } else {
        break;
      }
      // free p14
    }
    if (r11.length === 0) {
      r11 = peg$FAILED;
    }
    // bts <- r11
    if (r11===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_3;
    }
    // free r12
    p14 = peg$currPos;
    r12 = peg$discardeolf(true);
    if (r12!==peg$FAILED) {
      r12 = void 0;
      peg$currPos = p14;
    } else {
      peg$currPos = p8;
      r5 = peg$FAILED;
      break seq_3;
    }
    // free p14
    r5 = true;
    } // seq_3
    if (r5!==peg$FAILED) {
      peg$savedPos = p7;
      r5 = peg$a50(r4, r11);
    }
    // free p8
    } // choice_2
    // r <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a51(r4, r5);
    }
    // free p3
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseblock_lines(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [18,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    r8 = peg$parseoptionalSpaceToken(silence);
    // os <- r8
    if (r8===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    r9 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // so <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a52(r4, r8, r9);
    } else {
      r5 = null;
    }
    // free p7
    // s2 <- r5
    r10 = peg$parseblock_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // bl <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a53(r4, r5, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardeolf(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 249;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardnewline(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardeof(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseblock_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [140,boolParams & 0x33af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c69);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parsexmlish_tag_opened(silence, boolParams | 0xc00, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parsexmlish_tag_opened(silence, (boolParams & ~0x800) | 0x400, param_templatedepth, param_preproc, param_th);
    } // choice_1
    // tag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a54(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseparagraph(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [24,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s1 <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // s2 <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // c <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a55(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [228,boolParams & 0x13af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    choice_1: {
    r3 = peg$parseempty_line_with_comments(silence);
    if (r3!==peg$FAILED) {
      break choice_1;
    }
    r3 = peg$parsesol_prefix(silence);
    } // choice_1
    if (r3===peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$parsecomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = [r3,r4];
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$discardtplarg(silence, boolParams, param_templatedepth, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [71,boolParams & 0x3bff,param_templatedepth,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$discardtplarg_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}}"), param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetemplate(silence, boolParams, param_templatedepth, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [64,boolParams & 0x3bff,param_templatedepth,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parsetemplate_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}}"), param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebroken_template(silence, param_preproc) {
    var r1,p2,p3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [66,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    // t <- r4
    if (r4 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c70);}
      r4 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a56(param_preproc, r4);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsetplarg(silence, boolParams, param_templatedepth, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [70,boolParams & 0x3bff,param_templatedepth,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parsetplarg_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}}"), param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardwikilink(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [113,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardwikilink_preproc(silence, boolParams, param_templatedepth, new peg$Reference("]]"), param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardbroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [252,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsecomment(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    seq_1: {
    p2 = peg$currPos;
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "-{") {
      peg$currPos += 2;
      r4 = void 0;
      peg$currPos = p3;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p3
    r5 = peg$parselang_variant_or_tpl(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // v <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = [r4,r5];
    } // seq_1
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    // free p2
    seq_2: {
    p2 = peg$currPos;
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 38) {
      r6 = "&";
      peg$currPos += 1;
      r6 = void 0;
      peg$currPos = p3;
    } else {
      r6 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p3
    r7 = peg$parsehtmlentity(silence);
    // e <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = [r6,r7];
    } // seq_2
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    // free p2
    r1 = peg$parseinclude_limits(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardxmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [137,boolParams & 0x33af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c69);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parsexmlish_tag_opened(silence, (boolParams & ~0x400) | 0x800, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parsexmlish_tag_opened(silence, boolParams & ~0xc00, param_templatedepth, param_preproc, param_th);
    } // choice_1
    // tag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a54(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [268,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-!['\r\n|]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c71);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      seq_1: {
      p5 = peg$currPos;
      p7 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      choice_2: {
      r8 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8!==peg$FAILED) {
        break choice_2;
      }
      r8 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r8)) {
        peg$currPos++;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c72);}
      }
      } // choice_2
      if (r8===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r8];
      } // seq_1
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a57(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [270,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-!["\r\n|]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c73);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      seq_1: {
      p5 = peg$currPos;
      p7 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      choice_2: {
      r8 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8!==peg$FAILED) {
        break choice_2;
      }
      r8 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r8)) {
        peg$currPos++;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c72);}
      }
      } // choice_2
      if (r8===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r8];
      } // seq_1
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a57(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_attribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [266,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-![ \t\n\r\f|]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c74);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      seq_1: {
      p5 = peg$currPos;
      p7 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      choice_2: {
      r8 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8!==peg$FAILED) {
        break choice_2;
      }
      r8 = input.charAt(peg$currPos);
      if (/^[{}&<\-![]/.test(r8)) {
        peg$currPos++;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c72);}
      }
      } // choice_2
      if (r8===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r8];
      } // seq_1
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a57(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseless_than(silence, boolParams) {
    var p1,r2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [144,boolParams & 0x800].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (/*extTag*/(boolParams & 0x800) !== 0) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 60) {
      r5 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c69);}
      r5 = peg$FAILED;
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parseattribute_preprocessor_text_single(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [262,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/'>]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c75);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      seq_1: {
      p5 = peg$currPos;
      p7 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      p7 = peg$currPos;
      r8 = input.substr(peg$currPos,2);
      if (r8 === "/>") {
        peg$currPos += 2;
      } else {
        r8 = peg$FAILED;
      }
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p7;
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = peg$parseless_than(silence, boolParams);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c76);}
      }
      } // choice_2
      if (r9===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r8,r9];
      } // seq_1
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a57(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseattribute_preprocessor_text_double(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [264,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/">]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c77);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      seq_1: {
      p5 = peg$currPos;
      p7 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      p7 = peg$currPos;
      r8 = input.substr(peg$currPos,2);
      if (r8 === "/>") {
        peg$currPos += 2;
      } else {
        r8 = peg$FAILED;
      }
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p7;
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = peg$parseless_than(silence, boolParams);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c76);}
      }
      } // choice_2
      if (r9===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r8,r9];
      } // seq_1
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a57(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseattribute_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [260,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p5 = peg$currPos;
      r4 = peg$FAILED;
      for (;;) {
        r6 = input.charAt(peg$currPos);
        if (/^[^{}&<\-|\/ \t\n\r\f>]/.test(r6)) {
          peg$currPos++;
          r4 = true;
        } else {
          r6 = peg$FAILED;
          if (!silence) {peg$fail(peg$c78);}
          break;
        }
      }
      if (r4!==peg$FAILED) {
        r4 = input.substring(p5, peg$currPos);
        break choice_1;
      } else {
        r4 = peg$FAILED;
      }
      // free r6
      // free p5
      seq_1: {
      p5 = peg$currPos;
      p7 = peg$currPos;
      r6 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p7;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      p7 = peg$currPos;
      r8 = input.substr(peg$currPos,2);
      if (r8 === "/>") {
        peg$currPos += 2;
      } else {
        r8 = peg$FAILED;
      }
      if (r8 === peg$FAILED) {
        r8 = void 0;
      } else {
        r8 = peg$FAILED;
        peg$currPos = p7;
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p7
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = peg$parseless_than(silence, boolParams);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      r9 = input.charAt(peg$currPos);
      if (/^[{}&\-|\/]/.test(r9)) {
        peg$currPos++;
      } else {
        r9 = peg$FAILED;
        if (!silence) {peg$fail(peg$c76);}
      }
      } // choice_2
      if (r9===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r8,r9];
      } // seq_1
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a57(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseautolink(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [42,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    if (!(/*extlink*/(boolParams & 0x4) !== 0)) {
      r3 = void 0;
    } else {
      r3 = peg$FAILED;
      r2 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$a58();
    if (!r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parseautourl(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parseautoref(silence);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parseisbn(silence);
    } // choice_1
    // r <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = [r3,r4,r5];
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parsebehavior_switch(silence) {
    var r1,p2,r3,p4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 38;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "__") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c79);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$discardbehavior_text(silence);
    if (r7===peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r8 = input.substr(peg$currPos,2);
    if (r8 === "__") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c79);}
      r8 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    // bs <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a59(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [136,boolParams & 0x33af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r4 = "<";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c69);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    r5 = peg$parsexmlish_tag_opened(silence, (boolParams & ~0x400) | 0x800, param_templatedepth, param_preproc, param_th);
    if (r5!==peg$FAILED) {
      break choice_1;
    }
    r5 = peg$parsexmlish_tag_opened(silence, boolParams & ~0xc00, param_templatedepth, param_preproc, param_th);
    } // choice_1
    // tag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a54(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_or_tpl(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1,p2,p3,p4,r5,p6,r7,p8,r9,p10,r11,r12,p13,r14,r15,r16,r17,r18,r19,r20,p21,r22,r23,r24,r25,r26,r27,r28,p29,r30,r31;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [82,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = input.substr(peg$currPos,2);
    if (r7 === "-{") {
      peg$currPos += 2;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    p8 = peg$currPos;
    seq_3: {
    p10 = peg$currPos;
    r11 = peg$FAILED;
    for (;;) {
      r12 = input.substr(peg$currPos,3);
      if (r12 === "{{{") {
        peg$currPos += 3;
        r11 = true;
      } else {
        r12 = peg$FAILED;
        break;
      }
    }
    if (r11===peg$FAILED) {
      r9 = peg$FAILED;
      break seq_3;
    }
    // free r12
    p13 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r12 = "{";
      peg$currPos += 1;
    } else {
      r12 = peg$FAILED;
    }
    if (r12 === peg$FAILED) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      peg$currPos = p13;
      peg$currPos = p10;
      r9 = peg$FAILED;
      break seq_3;
    }
    // free p13
    r9 = true;
    } // seq_3
    if (r9!==peg$FAILED) {
      r9 = void 0;
      peg$currPos = p8;
    } else {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free p10
    // free p8
    r14 = peg$discardtplarg(true, boolParams, param_templatedepth, param_th);
    if (r14===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    r15 = peg$parselang_variant(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // a <- r15
    if (r15===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a36(r15);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p4 = peg$currPos;
    p6 = peg$currPos;
    seq_5: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      r17 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c80);}
      r17 = peg$FAILED;
      r16 = peg$FAILED;
      break seq_5;
    }
    p10 = peg$currPos;
    seq_6: {
    p13 = peg$currPos;
    r19 = peg$FAILED;
    for (;;) {
      r20 = input.substr(peg$currPos,3);
      if (r20 === "{{{") {
        peg$currPos += 3;
        r19 = true;
      } else {
        r20 = peg$FAILED;
        break;
      }
    }
    if (r19===peg$FAILED) {
      r18 = peg$FAILED;
      break seq_6;
    }
    // free r20
    p21 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r20 = "{";
      peg$currPos += 1;
    } else {
      r20 = peg$FAILED;
    }
    if (r20 === peg$FAILED) {
      r20 = void 0;
    } else {
      r20 = peg$FAILED;
      peg$currPos = p21;
      peg$currPos = p13;
      r18 = peg$FAILED;
      break seq_6;
    }
    // free p21
    r18 = true;
    } // seq_6
    if (r18!==peg$FAILED) {
      r18 = void 0;
      peg$currPos = p10;
    } else {
      peg$currPos = p8;
      r16 = peg$FAILED;
      break seq_5;
    }
    // free p13
    // free p10
    r16 = true;
    } // seq_5
    // a <- r16
    if (r16!==peg$FAILED) {
      r16 = input.substring(p6, peg$currPos);
    } else {
      r16 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free p8
    // free p6
    r22 = peg$parsetplarg(silence, boolParams, param_templatedepth, param_th);
    // b <- r22
    if (r22===peg$FAILED) {
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a37(r16, r22);
      break choice_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_7: {
    p6 = peg$currPos;
    p8 = peg$currPos;
    seq_8: {
    p10 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      r24 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c80);}
      r24 = peg$FAILED;
      r23 = peg$FAILED;
      break seq_8;
    }
    p13 = peg$currPos;
    seq_9: {
    p21 = peg$currPos;
    r26 = input.substr(peg$currPos,2);
    if (r26 === "{{") {
      peg$currPos += 2;
    } else {
      r26 = peg$FAILED;
      r25 = peg$FAILED;
      break seq_9;
    }
    for (;;) {
      r28 = input.substr(peg$currPos,3);
      if (r28 === "{{{") {
        peg$currPos += 3;
      } else {
        r28 = peg$FAILED;
        break;
      }
    }
    // free r28
    r27 = true;
    if (r27===peg$FAILED) {
      peg$currPos = p21;
      r25 = peg$FAILED;
      break seq_9;
    }
    // free r27
    p29 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      r27 = "{";
      peg$currPos += 1;
    } else {
      r27 = peg$FAILED;
    }
    if (r27 === peg$FAILED) {
      r27 = void 0;
    } else {
      r27 = peg$FAILED;
      peg$currPos = p29;
      peg$currPos = p21;
      r25 = peg$FAILED;
      break seq_9;
    }
    // free p29
    r25 = true;
    } // seq_9
    if (r25!==peg$FAILED) {
      r25 = void 0;
      peg$currPos = p13;
    } else {
      peg$currPos = p10;
      r23 = peg$FAILED;
      break seq_8;
    }
    // free p21
    // free p13
    r23 = true;
    } // seq_8
    // a <- r23
    if (r23!==peg$FAILED) {
      r23 = input.substring(p8, peg$currPos);
    } else {
      r23 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_7;
    }
    // free p10
    // free p8
    r28 = peg$parsetemplate(silence, boolParams, param_templatedepth, param_th);
    // b <- r28
    if (r28===peg$FAILED) {
      peg$currPos = p6;
      r1 = peg$FAILED;
      break seq_7;
    }
    r1 = true;
    } // seq_7
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a37(r23, r28);
      break choice_1;
    }
    // free p6
    p6 = peg$currPos;
    seq_10: {
    p8 = peg$currPos;
    p10 = peg$currPos;
    r30 = input.substr(peg$currPos,2);
    if (r30 === "-{") {
      peg$currPos += 2;
      r30 = void 0;
      peg$currPos = p10;
    } else {
      r30 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_10;
    }
    // free p10
    r31 = peg$parselang_variant(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // a <- r31
    if (r31===peg$FAILED) {
      peg$currPos = p8;
      r1 = peg$FAILED;
      break seq_10;
    }
    r1 = true;
    } // seq_10
    if (r1!==peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$a36(r31);
    }
    // free p8
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsewikilink(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [112,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsewikilink_preproc(silence, boolParams, param_templatedepth, new peg$Reference("]]"), param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsebroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsequote(silence) {
    var r1,p2,r3,p4,p5,r6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 122;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = input.substr(peg$currPos,2);
    if (r6 === "''") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c81);}
      r6 = peg$FAILED;
      r3 = peg$FAILED;
      break seq_1;
    }
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 39) {
        r8 = "'";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c57);}
        r8 = peg$FAILED;
        break;
      }
    }
    // free r8
    r7 = true;
    if (r7===peg$FAILED) {
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free r7
    r3 = true;
    } // seq_1
    // quotes <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a60(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseinclude_limits(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,p6,r7,r8,r9,p10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [238,boolParams & 0x33af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r7 = "<";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r8 = "/";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      r8 = null;
    }
    p10 = peg$currPos;
    r9 = peg$FAILED;
    for (;;) {
      r11 = input.charAt(peg$currPos);
      if (/^[oyinclude]/i.test(r11)) {
        peg$currPos++;
        r9 = true;
      } else {
        r11 = peg$FAILED;
        break;
      }
    }
    // n <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p10, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r11
    // free p10
    peg$savedPos = peg$currPos;
    r11 = peg$a61(r9);
    if (r11) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    r12 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // il <- r12
    if (r12===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r13 = peg$a62(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    if (r13) {
      r13 = void 0;
    } else {
      r13 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a63(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseheading(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,p7,r8,p9,r10,r11,p12,r13,p14,r15,r16,r17,r18,r19;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [34,boolParams & 0x3bfd,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r5 = "=";
      peg$currPos += 1;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    p9 = peg$currPos;
    r8 = peg$FAILED;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 61) {
        r10 = "=";
        peg$currPos += 1;
        r8 = true;
      } else {
        if (!silence) {peg$fail(peg$c45);}
        r10 = peg$FAILED;
        break;
      }
    }
    // s <- r8
    if (r8!==peg$FAILED) {
      r8 = input.substring(p9, peg$currPos);
    } else {
      r8 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free r10
    // free p9
    seq_3: {
    p9 = peg$currPos;
    p12 = peg$currPos;
    r13 = peg$parseinlineline(silence, boolParams | 0x2, param_templatedepth, param_preproc, param_th);
    if (r13===peg$FAILED) {
      r13 = null;
    }
    // ill <- r13
    r11 = r13;
    if (r11!==peg$FAILED) {
      peg$savedPos = p12;
      r11 = peg$a64(r8, r13);
    } else {
      r10 = peg$FAILED;
      break seq_3;
    }
    p14 = peg$currPos;
    r15 = peg$FAILED;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 61) {
        r16 = "=";
        peg$currPos += 1;
        r15 = true;
      } else {
        if (!silence) {peg$fail(peg$c45);}
        r16 = peg$FAILED;
        break;
      }
    }
    if (r15!==peg$FAILED) {
      r15 = input.substring(p14, peg$currPos);
    } else {
      r15 = peg$FAILED;
      peg$currPos = p9;
      r10 = peg$FAILED;
      break seq_3;
    }
    // free r16
    // free p14
    r10 = [r11,r15];
    } // seq_3
    if (r10===peg$FAILED) {
      r10 = null;
    }
    // free p9
    // ce <- r10
    peg$savedPos = peg$currPos;
    r16 = peg$a65(r8, r10);
    if (r16) {
      r16 = void 0;
    } else {
      r16 = peg$FAILED;
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    p9 = peg$currPos;
    r17 = '';
    // endTPos <- r17
    if (r17!==peg$FAILED) {
      peg$savedPos = p9;
      r17 = peg$a66(r8, r10);
    } else {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r18 = [];
    for (;;) {
      choice_1: {
      r19 = peg$parsespaces(silence);
      if (r19!==peg$FAILED) {
        break choice_1;
      }
      r19 = peg$parsecomment(silence);
      } // choice_1
      if (r19!==peg$FAILED) {
        r18.push(r19);
      } else {
        break;
      }
    }
    // spc <- r18
    // free r19
    p14 = peg$currPos;
    r19 = peg$discardeolf(true);
    if (r19!==peg$FAILED) {
      r19 = void 0;
      peg$currPos = p14;
    } else {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free p14
    r6 = true;
    } // seq_2
    // r <- r6
    if (r6!==peg$FAILED) {
      peg$savedPos = p4;
      r6 = peg$a67(r8, r10, r17, r18);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a68(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselist_item(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [154,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsedtdd(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsehacky_dl_uses(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseli(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsehr(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,p8,p9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [20,boolParams & 0x13af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "----") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c82);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 45) {
        r7 = "-";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c80);}
        r7 = peg$FAILED;
        break;
      }
    }
    // free r7
    r5 = true;
    // d <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    choice_1: {
    p6 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    p9 = peg$currPos;
    r10 = peg$discardsol(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10!==peg$FAILED) {
      r10 = void 0;
      peg$currPos = p9;
    } else {
      r7 = peg$FAILED;
      break seq_2;
    }
    // free p9
    r7 = true;
    } // seq_2
    if (r7!==peg$FAILED) {
      peg$savedPos = p6;
      r7 = peg$a69(r5);
      break choice_1;
    }
    // free p8
    p8 = peg$currPos;
    r7 = '';
    if (r7!==peg$FAILED) {
      peg$savedPos = p8;
      r7 = peg$a70(r5);
    }
    } // choice_1
    // lineContent <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a71(r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [170,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r4 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4 === peg$FAILED) {
      r4 = void 0;
      break choice_1;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
    }
    // free p5
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,5);
    if (r4 === "{{!}}") {
      peg$currPos += 5;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
    }
    // free p5
    } // choice_1
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    seq_2: {
    p5 = peg$currPos;
    r7 = peg$parsetable_start_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    r8 = peg$parseoptionalNewlines(silence);
    if (r8===peg$FAILED) {
      peg$currPos = p5;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = [r7,r8];
    } // seq_2
    if (r6!==peg$FAILED) {
      break choice_2;
    }
    // free p5
    seq_3: {
    p5 = peg$currPos;
    r9 = peg$parsetable_content_line(silence, boolParams | 0x10, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      r6 = peg$FAILED;
      break seq_3;
    }
    r10 = peg$parseoptionalNewlines(silence);
    if (r10===peg$FAILED) {
      peg$currPos = p5;
      r6 = peg$FAILED;
      break seq_3;
    }
    r6 = [r9,r10];
    } // seq_3
    if (r6!==peg$FAILED) {
      break choice_2;
    }
    // free p5
    r6 = peg$parsetable_end_tag(silence);
    } // choice_2
    // tl <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a72(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsexmlish_tag_opened(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [138,boolParams & 0x3faf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      r4 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c59);}
      r4 = peg$FAILED;
      r4 = null;
    }
    // end <- r4
    r5 = peg$parsetag_name(silence);
    // name <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r6 = peg$a73(r4, r5, /*extTag*/(boolParams & 0x800) !== 0, /*isBlock*/(boolParams & 0x400) !== 0);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsegeneric_newline_attributes(silence, boolParams & ~0x50, param_templatedepth, param_preproc, param_th);
    // attribs <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    for (;;) {
      r9 = peg$discardspace_or_newline_or_solidus(silence);
      if (r9===peg$FAILED) {
        break;
      }
    }
    // free r9
    r8 = true;
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    if (input.charCodeAt(peg$currPos) === 47) {
      r8 = "/";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c59);}
      r8 = peg$FAILED;
      r8 = null;
    }
    // selfclose <- r8
    for (;;) {
      r10 = peg$discardspace(silence);
      if (r10===peg$FAILED) {
        break;
      }
    }
    // free r10
    r9 = true;
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r9
    if (input.charCodeAt(peg$currPos) === 62) {
      r9 = ">";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c83);}
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a74(r4, r5, /*extTag*/(boolParams & 0x800) !== 0, /*isBlock*/(boolParams & 0x400) !== 0, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseempty_line_with_comments(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 232;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol_prefix(silence);
    // sp <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a75(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      seq_2: {
      p9 = peg$currPos;
      r10 = [];
      for (;;) {
        r11 = peg$parsespace(silence);
        if (r11!==peg$FAILED) {
          r10.push(r11);
        } else {
          break;
        }
      }
      // free r11
      r11 = peg$parsecomment(silence);
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r12 = [];
      for (;;) {
        choice_1: {
        r13 = peg$parsespace(silence);
        if (r13!==peg$FAILED) {
          break choice_1;
        }
        r13 = peg$parsecomment(silence);
        } // choice_1
        if (r13!==peg$FAILED) {
          r12.push(r13);
        } else {
          break;
        }
      }
      // free r13
      r13 = peg$parsenewline(silence);
      if (r13===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = [r10,r11,r12,r13];
      } // seq_2
      if (r8!==peg$FAILED) {
        r7.push(r8);
      } else {
        break;
      }
      // free p9
    }
    if (r7.length === 0) {
      r7 = peg$FAILED;
    }
    // c <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a76(r4, r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsesol_prefix(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 230;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsenewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    peg$savedPos = peg$currPos;
    r1 = peg$a77();
    if (r1) {
      r1 = void 0;
      peg$savedPos = p2;
      r1 = peg$a78();
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardtplarg_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,r11,r12,r13,p14,p15,r16,p17,r18,r19,p20,p21,r22,r23;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [73,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,3);
    if (r4 === "{{{") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c84);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a26();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // target <- r7
    r8 = [];
    for (;;) {
      seq_2: {
      p10 = peg$currPos;
      r11 = [];
      for (;;) {
        r12 = peg$parsenl_comment_space(silence);
        if (r12!==peg$FAILED) {
          r11.push(r12);
        } else {
          break;
        }
      }
      // free r12
      if (input.charCodeAt(peg$currPos) === 124) {
        r12 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r12 = peg$FAILED;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      choice_1: {
      p14 = peg$currPos;
      seq_3: {
      p15 = peg$currPos;
      p17 = peg$currPos;
      r16 = '';
      // p0 <- r16
      if (r16!==peg$FAILED) {
        peg$savedPos = p17;
        r16 = peg$a79(r5, r7);
      } else {
        r13 = peg$FAILED;
        break seq_3;
      }
      r18 = [];
      for (;;) {
        r19 = peg$parsenl_comment_space(silence);
        if (r19!==peg$FAILED) {
          r18.push(r19);
        } else {
          break;
        }
      }
      // v <- r18
      // free r19
      p20 = peg$currPos;
      r19 = '';
      // p1 <- r19
      if (r19!==peg$FAILED) {
        peg$savedPos = p20;
        r19 = peg$a80(r5, r7, r16, r18);
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      p21 = peg$currPos;
      choice_2: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r22 = "|";
        peg$currPos += 1;
        break choice_2;
      } else {
        r22 = peg$FAILED;
      }
      r22 = input.substr(peg$currPos,3);
      if (r22 === "}}}") {
        peg$currPos += 3;
      } else {
        r22 = peg$FAILED;
      }
      } // choice_2
      if (r22!==peg$FAILED) {
        r22 = void 0;
        peg$currPos = p21;
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      // free p21
      r13 = true;
      } // seq_3
      if (r13!==peg$FAILED) {
        peg$savedPos = p14;
        r13 = peg$a81(r5, r7, r16, r18, r19);
        break choice_1;
      }
      // free p15
      r13 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_1
      // r <- r13
      if (r13===peg$FAILED) {
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = [r11,r12,r13];
      } // seq_2
      if (r9!==peg$FAILED) {
        r8.push(r9);
      } else {
        break;
      }
      // free p10
    }
    // params <- r8
    // free r9
    for (;;) {
      r23 = peg$discardnl_comment_space(silence);
      if (r23===peg$FAILED) {
        break;
      }
    }
    // free r23
    r9 = true;
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r9
    r9 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r23 = input.substr(peg$currPos,3);
    if (r23 === "}}}") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c85);}
      r23 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a82(r5, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetemplate_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,r11,r12,p13,p14,r15,p16,r17,r18,p19,p20,r21,r22,r23,r24,r25,r26;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [68,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c70);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      r7 = peg$discardnl_comment_space(silence);
      if (r7===peg$FAILED) {
        break;
      }
    }
    // free r7
    r5 = true;
    // leadWS <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r7 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // target <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    for (;;) {
      p6 = peg$currPos;
      seq_2: {
      p10 = peg$currPos;
      for (;;) {
        r12 = peg$discardnl_comment_space(silence);
        if (r12===peg$FAILED) {
          break;
        }
      }
      // free r12
      r11 = true;
      if (r11===peg$FAILED) {
        r9 = peg$FAILED;
        break seq_2;
      }
      // free r11
      if (input.charCodeAt(peg$currPos) === 124) {
        r11 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r11 = peg$FAILED;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      choice_2: {
      p13 = peg$currPos;
      seq_3: {
      p14 = peg$currPos;
      p16 = peg$currPos;
      r15 = '';
      // p0 <- r15
      if (r15!==peg$FAILED) {
        peg$savedPos = p16;
        r15 = peg$a83(r5, r7);
      } else {
        r12 = peg$FAILED;
        break seq_3;
      }
      r17 = [];
      for (;;) {
        r18 = peg$parsenl_comment_space(silence);
        if (r18!==peg$FAILED) {
          r17.push(r18);
        } else {
          break;
        }
      }
      // v <- r17
      // free r18
      p19 = peg$currPos;
      r18 = '';
      // p <- r18
      if (r18!==peg$FAILED) {
        peg$savedPos = p19;
        r18 = peg$a84(r5, r7, r15, r17);
      } else {
        peg$currPos = p14;
        r12 = peg$FAILED;
        break seq_3;
      }
      p20 = peg$currPos;
      choice_3: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r21 = "|";
        peg$currPos += 1;
        break choice_3;
      } else {
        r21 = peg$FAILED;
      }
      r21 = input.substr(peg$currPos,2);
      if (r21 === "}}") {
        peg$currPos += 2;
      } else {
        r21 = peg$FAILED;
      }
      } // choice_3
      if (r21!==peg$FAILED) {
        r21 = void 0;
        peg$currPos = p20;
      } else {
        peg$currPos = p14;
        r12 = peg$FAILED;
        break seq_3;
      }
      // free p20
      r12 = true;
      } // seq_3
      if (r12!==peg$FAILED) {
        peg$savedPos = p13;
        r12 = peg$a85(r5, r7, r15, r17, r18);
        break choice_2;
      }
      // free p14
      r12 = peg$parsetemplate_param(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_2
      // r <- r12
      if (r12===peg$FAILED) {
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = true;
      } // seq_2
      if (r9!==peg$FAILED) {
        peg$savedPos = p6;
        r9 = peg$a86(r5, r7, r12);
        r8.push(r9);
      } else {
        break;
      }
      // free p10
    }
    // params <- r8
    // free r9
    p10 = peg$currPos;
    for (;;) {
      r22 = peg$discardnl_comment_space(silence);
      if (r22===peg$FAILED) {
        break;
      }
    }
    // free r22
    r9 = true;
    // trailWS <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p10, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p10
    r22 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r22===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r23 = input.substr(peg$currPos,2);
    if (r23 === "}}") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c86);}
      r23 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a87(r5, r7, r8, r9);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_4: {
    p10 = peg$currPos;
    r24 = input.substr(peg$currPos,2);
    if (r24 === "{{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c70);}
      r24 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_4;
    }
    for (;;) {
      r26 = peg$discardspace_or_newline(silence);
      if (r26===peg$FAILED) {
        break;
      }
    }
    // free r26
    r25 = true;
    if (r25===peg$FAILED) {
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_4;
    }
    // free r25
    r25 = input.substr(peg$currPos,2);
    if (r25 === "}}") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c86);}
      r25 = peg$FAILED;
      peg$currPos = p10;
      r1 = peg$FAILED;
      break seq_4;
    }
    r1 = true;
    } // seq_4
    if (r1!==peg$FAILED) {
      r1 = input.substring(p3, peg$currPos);
    } else {
      r1 = peg$FAILED;
    }
    // free p10
    // free p3
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetplarg_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,r11,r12,r13,p14,p15,r16,p17,r18,r19,p20,p21,r22,r23;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [72,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,3);
    if (r4 === "{{{") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c84);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a26();
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // target <- r7
    r8 = [];
    for (;;) {
      seq_2: {
      p10 = peg$currPos;
      r11 = [];
      for (;;) {
        r12 = peg$parsenl_comment_space(silence);
        if (r12!==peg$FAILED) {
          r11.push(r12);
        } else {
          break;
        }
      }
      // free r12
      if (input.charCodeAt(peg$currPos) === 124) {
        r12 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r12 = peg$FAILED;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      choice_1: {
      p14 = peg$currPos;
      seq_3: {
      p15 = peg$currPos;
      p17 = peg$currPos;
      r16 = '';
      // p0 <- r16
      if (r16!==peg$FAILED) {
        peg$savedPos = p17;
        r16 = peg$a79(r5, r7);
      } else {
        r13 = peg$FAILED;
        break seq_3;
      }
      r18 = [];
      for (;;) {
        r19 = peg$parsenl_comment_space(silence);
        if (r19!==peg$FAILED) {
          r18.push(r19);
        } else {
          break;
        }
      }
      // v <- r18
      // free r19
      p20 = peg$currPos;
      r19 = '';
      // p1 <- r19
      if (r19!==peg$FAILED) {
        peg$savedPos = p20;
        r19 = peg$a80(r5, r7, r16, r18);
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      p21 = peg$currPos;
      choice_2: {
      if (input.charCodeAt(peg$currPos) === 124) {
        r22 = "|";
        peg$currPos += 1;
        break choice_2;
      } else {
        r22 = peg$FAILED;
      }
      r22 = input.substr(peg$currPos,3);
      if (r22 === "}}}") {
        peg$currPos += 3;
      } else {
        r22 = peg$FAILED;
      }
      } // choice_2
      if (r22!==peg$FAILED) {
        r22 = void 0;
        peg$currPos = p21;
      } else {
        peg$currPos = p15;
        r13 = peg$FAILED;
        break seq_3;
      }
      // free p21
      r13 = true;
      } // seq_3
      if (r13!==peg$FAILED) {
        peg$savedPos = p14;
        r13 = peg$a81(r5, r7, r16, r18, r19);
        break choice_1;
      }
      // free p15
      r13 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_1
      // r <- r13
      if (r13===peg$FAILED) {
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = [r11,r12,r13];
      } // seq_2
      if (r9!==peg$FAILED) {
        r8.push(r9);
      } else {
        break;
      }
      // free p10
    }
    // params <- r8
    // free r9
    for (;;) {
      r23 = peg$discardnl_comment_space(silence);
      if (r23===peg$FAILED) {
        break;
      }
    }
    // free r23
    r9 = true;
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r9
    r9 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r23 = input.substr(peg$currPos,3);
    if (r23 === "}}}") {
      peg$currPos += 3;
    } else {
      if (!silence) {peg$fail(peg$c85);}
      r23 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a82(r5, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardwikilink_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [117,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "[[") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c65);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsewikilink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5===peg$FAILED) {
      r5 = null;
    }
    // target <- r5
    p7 = peg$currPos;
    r6 = '';
    // tpos <- r6
    if (r6!==peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$a88(r5);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsewikilink_content(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lcs <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = input.substr(peg$currPos,2);
    if (r10 === "]]") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c87);}
      r10 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a89(r5, r6, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardbroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th) {
    var r1,p2,p3,p4,r5,r6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [115,boolParams & 0x3bff,param_preproc.value,param_templatedepth,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "[[") {
      peg$currPos += 2;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    peg$savedPos = peg$currPos;
    r6 = peg$a90(param_preproc);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r8 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r9 = peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 91) {
      r9 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r9 = peg$FAILED;
    }
    } // choice_1
    if (r9===peg$FAILED) {
      peg$currPos = p4;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = [r8,r9];
    } // seq_2
    // a <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a91(param_preproc, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [124,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*extTag*/(boolParams & 0x800) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r6 = peg$a92(r5);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a93(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseautourl(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,p7,r8,r9,r10,r11,p12,p13,r14,r15,r16,p17,r18,r19,r20,r21,r22,r23,r24,r25;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [54,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "//") {
      peg$currPos += 2;
    } else {
      r5 = peg$FAILED;
    }
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    p4 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    r8 = peg$parseurl_protocol(silence);
    // proto <- r8
    if (r8===peg$FAILED) {
      r6 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r9 = peg$parseIPAddress(silence);
    if (r9!==peg$FAILED) {
      break choice_1;
    }
    r9 = '';
    } // choice_1
    // addr <- r9
    if (r9===peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    r10 = [];
    for (;;) {
      choice_2: {
      seq_3: {
      p12 = peg$currPos;
      p13 = peg$currPos;
      r14 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r14 === peg$FAILED) {
        r14 = void 0;
      } else {
        r14 = peg$FAILED;
        peg$currPos = p13;
        r11 = peg$FAILED;
        break seq_3;
      }
      // free p13
      r15 = input.charAt(peg$currPos);
      // c <- r15
      if (/^[^&[\]{'"<>\0- \uFFFD \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r15)) {
        peg$currPos++;
      } else {
        r15 = peg$FAILED;
        if (!silence) {peg$fail(peg$c88);}
        peg$currPos = p12;
        r11 = peg$FAILED;
        break seq_3;
      }
      r11 = [r14,r15];
      } // seq_3
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      // free p12
      p12 = peg$currPos;
      seq_4: {
      p13 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        r16 = "'";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c57);}
        r16 = peg$FAILED;
        r11 = peg$FAILED;
        break seq_4;
      }
      p17 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        r18 = "'";
        peg$currPos += 1;
      } else {
        r18 = peg$FAILED;
      }
      if (r18 === peg$FAILED) {
        r18 = void 0;
      } else {
        r18 = peg$FAILED;
        peg$currPos = p17;
        peg$currPos = p13;
        r11 = peg$FAILED;
        break seq_4;
      }
      // free p17
      r11 = true;
      } // seq_4
      if (r11!==peg$FAILED) {
        r11 = input.substring(p12, peg$currPos);
        break choice_2;
      } else {
        r11 = peg$FAILED;
      }
      // free p13
      // free p12
      r11 = peg$parsecomment(silence);
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      r11 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      p12 = peg$currPos;
      r19 = input.charAt(peg$currPos);
      // s <- r19
      if (/^[:{]/.test(r19)) {
        peg$currPos++;
        r19 = input.substring(p12, peg$currPos);
      } else {
        r19 = peg$FAILED;
        if (!silence) {peg$fail(peg$c89);}
        r19 = peg$FAILED;
      }
      // free p12
      r11 = r19;
      if (r11!==peg$FAILED) {
        break choice_2;
      }
      seq_5: {
      p12 = peg$currPos;
      p13 = peg$currPos;
      seq_6: {
      p17 = peg$currPos;
      r21 = peg$parseraw_htmlentity(true);
      // rhe <- r21
      if (r21===peg$FAILED) {
        r20 = peg$FAILED;
        break seq_6;
      }
      peg$savedPos = peg$currPos;
      r22 = peg$a94(r8, r9, r15, r19, r21);
      if (r22) {
        r22 = void 0;
      } else {
        r22 = peg$FAILED;
        peg$currPos = p17;
        r20 = peg$FAILED;
        break seq_6;
      }
      r20 = true;
      } // seq_6
      // free p17
      if (r20 === peg$FAILED) {
        r20 = void 0;
      } else {
        r20 = peg$FAILED;
        peg$currPos = p13;
        r11 = peg$FAILED;
        break seq_5;
      }
      // free p13
      choice_3: {
      seq_7: {
      p13 = peg$currPos;
      p17 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        r24 = "&";
        peg$currPos += 1;
        r24 = void 0;
        peg$currPos = p17;
      } else {
        r24 = peg$FAILED;
        r23 = peg$FAILED;
        break seq_7;
      }
      // free p17
      r25 = peg$parsehtmlentity(silence);
      if (r25===peg$FAILED) {
        peg$currPos = p13;
        r23 = peg$FAILED;
        break seq_7;
      }
      r23 = [r24,r25];
      } // seq_7
      if (r23!==peg$FAILED) {
        break choice_3;
      }
      // free p13
      if (input.charCodeAt(peg$currPos) === 38) {
        r23 = "&";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c52);}
        r23 = peg$FAILED;
      }
      } // choice_3
      // r <- r23
      if (r23===peg$FAILED) {
        peg$currPos = p12;
        r11 = peg$FAILED;
        break seq_5;
      }
      r11 = [r20,r23];
      } // seq_5
      // free p12
      } // choice_2
      if (r11!==peg$FAILED) {
        r10.push(r11);
      } else {
        break;
      }
    }
    // path <- r10
    // free r11
    r6 = true;
    } // seq_2
    // r <- r6
    if (r6!==peg$FAILED) {
      peg$savedPos = p4;
      r6 = peg$a95(r8, r9, r10);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    peg$savedPos = peg$currPos;
    r11 = peg$a96(r6);
    if (r11) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a97(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseautoref(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 46;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    r4 = input.substr(peg$currPos,3);
    if (r4 === "RFC") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c90);}
      r4 = peg$FAILED;
    }
    r4 = input.substr(peg$currPos,4);
    if (r4 === "PMID") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c91);}
      r4 = peg$FAILED;
    }
    } // choice_1
    // ref <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = [];
    for (;;) {
      r6 = peg$parsespace_or_nbsp(silence);
      if (r6!==peg$FAILED) {
        r5.push(r6);
      } else {
        break;
      }
    }
    if (r5.length === 0) {
      r5 = peg$FAILED;
    }
    // sp <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r6
    p7 = peg$currPos;
    r6 = peg$FAILED;
    for (;;) {
      r8 = input.charAt(peg$currPos);
      if (/^[0-9]/.test(r8)) {
        peg$currPos++;
        r6 = true;
      } else {
        r8 = peg$FAILED;
        if (!silence) {peg$fail(peg$c92);}
        break;
      }
    }
    // identifier <- r6
    if (r6!==peg$FAILED) {
      r6 = input.substring(p7, peg$currPos);
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    // free p7
    r8 = peg$discardend_of_word(silence);
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a98(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseisbn(silence) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,r10,p11,r12,r13,r14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 48;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "ISBN") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c93);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = [];
    for (;;) {
      r6 = peg$parsespace_or_nbsp(silence);
      if (r6!==peg$FAILED) {
        r5.push(r6);
      } else {
        break;
      }
    }
    if (r5.length === 0) {
      r5 = peg$FAILED;
    }
    // sp <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r6
    seq_2: {
    p7 = peg$currPos;
    r8 = input.charAt(peg$currPos);
    if (/^[0-9]/.test(r8)) {
      peg$currPos++;
    } else {
      r8 = peg$FAILED;
      if (!silence) {peg$fail(peg$c92);}
      r6 = peg$FAILED;
      break seq_2;
    }
    r9 = [];
    for (;;) {
      seq_3: {
      p11 = peg$currPos;
      r12 = peg$parsespace_or_nbsp_or_dash(silence);
      if (r12===peg$FAILED) {
        r12 = null;
      }
      r13 = input.charAt(peg$currPos);
      if (/^[0-9]/.test(r13)) {
        peg$currPos++;
      } else {
        r13 = peg$FAILED;
        if (!silence) {peg$fail(peg$c92);}
        peg$currPos = p11;
        r10 = peg$FAILED;
        break seq_3;
      }
      r10 = [r12,r13];
      } // seq_3
      if (r10!==peg$FAILED) {
        r9.push(r10);
      } else {
        break;
      }
      // free p11
    }
    if (r9.length === 0) {
      r9 = peg$FAILED;
    }
    if (r9===peg$FAILED) {
      peg$currPos = p7;
      r6 = peg$FAILED;
      break seq_2;
    }
    // free r10
    r10 = peg$parsespace_or_nbsp_or_dash(silence);
    if (r10===peg$FAILED) {
      r10 = null;
    }
    r14 = input.charAt(peg$currPos);
    if (/^[xX]/.test(r14)) {
      peg$currPos++;
    } else {
      r14 = peg$FAILED;
      if (!silence) {peg$fail(peg$c94);}
      r14 = null;
    }
    r6 = [r8,r9,r10,r14];
    } // seq_2
    // isbn <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    p7 = peg$currPos;
    r15 = peg$discardend_of_word(silence);
    // isbncode <- r15
    if (r15!==peg$FAILED) {
      peg$savedPos = p7;
      r15 = peg$a99(r5, r6);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r16 = peg$a100(r5, r6, r15);
    if (r16) {
      r16 = void 0;
    } else {
      r16 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a101(r5, r6, r15);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardbehavior_text(silence) {
    var p1,r2,r3,p4,p5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 41;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    r2 = peg$FAILED;
    for (;;) {
      seq_1: {
      p4 = peg$currPos;
      p5 = peg$currPos;
      r6 = input.substr(peg$currPos,2);
      if (r6 === "__") {
        peg$currPos += 2;
      } else {
        r6 = peg$FAILED;
      }
      if (r6 === peg$FAILED) {
        r6 = void 0;
      } else {
        r6 = peg$FAILED;
        peg$currPos = p5;
        r3 = peg$FAILED;
        break seq_1;
      }
      // free p5
      r7 = input.charAt(peg$currPos);
      if (/^[^'"<~[{\n\r:;\]}|!=]/.test(r7)) {
        peg$currPos++;
      } else {
        r7 = peg$FAILED;
        if (!silence) {peg$fail(peg$c95);}
        peg$currPos = p4;
        r3 = peg$FAILED;
        break seq_1;
      }
      r3 = true;
      } // seq_1
      if (r3!==peg$FAILED) {
        r2 = true;
      } else {
        break;
      }
      // free p4
    }
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parselang_variant(silence, boolParams, param_templatedepth, param_th, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [86,boolParams & 0x3bff,param_templatedepth,param_th.value,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
            if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_th=param_th.value;
        var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parselang_variant_preproc(silence, boolParams, param_templatedepth, new peg$Reference("}-"), param_th);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsebroken_lang_variant(silence, param_preproc);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_th !== param_th.value) cached.$th = param_th.value;
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsewikilink_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [116,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    if (r4 === "[[") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c65);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsewikilink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5===peg$FAILED) {
      r5 = null;
    }
    // target <- r5
    p7 = peg$currPos;
    r6 = '';
    // tpos <- r6
    if (r6!==peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$a88(r5);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = peg$parsewikilink_content(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lcs <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r9 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = input.substr(peg$currPos,2);
    if (r10 === "]]") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c87);}
      r10 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a89(r5, r6, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebroken_wikilink(silence, boolParams, param_preproc, param_templatedepth, param_th) {
    var r1,p2,p3,p4,r5,r6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [114,boolParams & 0x3bff,param_preproc.value,param_templatedepth,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = input.substr(peg$currPos,2);
    if (r5 === "[[") {
      peg$currPos += 2;
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r5 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    peg$savedPos = peg$currPos;
    r6 = peg$a90(param_preproc);
    if (r6) {
      r6 = void 0;
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    seq_2: {
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 91) {
      r8 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r8 = peg$FAILED;
      r7 = peg$FAILED;
      break seq_2;
    }
    choice_1: {
    r9 = peg$parseextlink(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 91) {
      r9 = "[";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c42);}
      r9 = peg$FAILED;
    }
    } // choice_1
    if (r9===peg$FAILED) {
      peg$currPos = p4;
      r7 = peg$FAILED;
      break seq_2;
    }
    r7 = [r8,r9];
    } // seq_2
    // a <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a91(param_preproc, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsespaces(silence) {
    var p1,r2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 206;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    r2 = peg$FAILED;
    for (;;) {
      r3 = input.charAt(peg$currPos);
      if (/^[ \t]/.test(r3)) {
        peg$currPos++;
        r2 = true;
      } else {
        r3 = peg$FAILED;
        if (!silence) {peg$fail(peg$c9);}
        break;
      }
    }
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free r3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parsedtdd(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,p8,r9,p10,r11,p12,r13,r14,r15,r16,r17,r18;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [160,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      p6 = peg$currPos;
      seq_2: {
      p7 = peg$currPos;
      p8 = peg$currPos;
      seq_3: {
      p10 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        r11 = ";";
        peg$currPos += 1;
      } else {
        r11 = peg$FAILED;
        r9 = peg$FAILED;
        break seq_3;
      }
      p12 = peg$currPos;
      r13 = peg$discardlist_char(true);
      if (r13 === peg$FAILED) {
        r13 = void 0;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p12;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_3;
      }
      // free p12
      r9 = true;
      } // seq_3
      // free p10
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p8;
        r5 = peg$FAILED;
        break seq_2;
      }
      // free p8
      r14 = peg$parselist_char(silence);
      // lc <- r14
      if (r14===peg$FAILED) {
        peg$currPos = p7;
        r5 = peg$FAILED;
        break seq_2;
      }
      r5 = true;
      } // seq_2
      if (r5!==peg$FAILED) {
        peg$savedPos = p6;
        r5 = peg$a102(r14);
        r4.push(r5);
      } else {
        break;
      }
      // free p7
    }
    // bullets <- r4
    // free r5
    if (input.charCodeAt(peg$currPos) === 59) {
      r5 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c54);}
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r15 = peg$parseinlineline_break_on_colon(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // c <- r15
    p7 = peg$currPos;
    // cpos <- r16
    if (input.charCodeAt(peg$currPos) === 58) {
      r16 = ":";
      peg$currPos += 1;
      peg$savedPos = p7;
      r16 = peg$a103(r4, r15);
    } else {
      if (!silence) {peg$fail(peg$c68);}
      r16 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r17 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r17===peg$FAILED) {
      r17 = null;
    }
    // d <- r17
    p8 = peg$currPos;
    r18 = peg$discardeolf(true);
    if (r18!==peg$FAILED) {
      r18 = void 0;
      peg$currPos = p8;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a104(r4, r15, r16, r17);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsehacky_dl_uses(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,p10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [158,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 58) {
        r5 = ":";
        peg$currPos += 1;
        r4.push(r5);
      } else {
        if (!silence) {peg$fail(peg$c68);}
        r5 = peg$FAILED;
        break;
      }
    }
    if (r4.length === 0) {
      r4 = peg$FAILED;
    }
    // bullets <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r5
    seq_2: {
    p6 = peg$currPos;
    r7 = peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    r8 = [];
    for (;;) {
      seq_3: {
      p10 = peg$currPos;
      r11 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11===peg$FAILED) {
        r9 = peg$FAILED;
        break seq_3;
      }
      r12 = peg$parsetable_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r12===peg$FAILED) {
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_3;
      }
      r9 = [r11,r12];
      } // seq_3
      if (r9!==peg$FAILED) {
        r8.push(r9);
      } else {
        break;
      }
      // free p10
    }
    // free r9
    r5 = [r7,r8];
    } // seq_2
    // tbl <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r9 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r9===peg$FAILED) {
      r9 = null;
    }
    // line <- r9
    p6 = peg$currPos;
    r13 = peg$discardcomment_space_eolf(true);
    if (r13!==peg$FAILED) {
      r13 = void 0;
      peg$currPos = p6;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a105(r4, r5, r9);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseli(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [156,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      r5 = peg$parselist_char(silence);
      if (r5!==peg$FAILED) {
        r4.push(r5);
      } else {
        break;
      }
    }
    if (r4.length === 0) {
      r4 = peg$FAILED;
    }
    // bullets <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r5
    r5 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5===peg$FAILED) {
      r5 = null;
    }
    // c <- r5
    p6 = peg$currPos;
    choice_1: {
    r7 = peg$discardeolf(true);
    if (r7!==peg$FAILED) {
      break choice_1;
    }
    r7 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (r7!==peg$FAILED) {
      r7 = void 0;
      peg$currPos = p6;
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a106(r4, r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardsol(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [229,boolParams & 0x13af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    choice_1: {
    r3 = peg$discardempty_line_with_comments(silence);
    if (r3!==peg$FAILED) {
      break choice_1;
    }
    r3 = peg$discardsol_prefix(silence);
    } // choice_1
    if (r3===peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    r4 = peg$discardcomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parseoptionalNewlines(silence) {
    var r1,p2,r3,p4,r5,p6,r7,p8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 224;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    for (;;) {
      seq_1: {
      p6 = peg$currPos;
      r7 = input.charAt(peg$currPos);
      if (/^[\n\r\t ]/.test(r7)) {
        peg$currPos++;
      } else {
        r7 = peg$FAILED;
        if (!silence) {peg$fail(peg$c96);}
        r5 = peg$FAILED;
        break seq_1;
      }
      p8 = peg$currPos;
      r9 = input.charAt(peg$currPos);
      if (/^[\n\r]/.test(r9)) {
        peg$currPos++;
        r9 = void 0;
        peg$currPos = p8;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p6;
        r5 = peg$FAILED;
        break seq_1;
      }
      // free p8
      r5 = true;
      } // seq_1
      if (r5===peg$FAILED) {
        break;
      }
      // free p6
    }
    // free r5
    r3 = true;
    // spc <- r3
    if (r3!==peg$FAILED) {
      r3 = input.substring(p4, peg$currPos);
    } else {
      r3 = peg$FAILED;
    }
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a107(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetable_content_line(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var p1,r2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [172,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parsespace(silence);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      r4 = peg$parsecomment(silence);
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // free r4
    choice_2: {
    r4 = peg$parsetable_heading_tags(silence, boolParams, param_templatedepth, param_preproc);
    if (r4!==peg$FAILED) {
      break choice_2;
    }
    r4 = peg$parsetable_row_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4!==peg$FAILED) {
      break choice_2;
    }
    r4 = peg$parsetable_data_tags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4!==peg$FAILED) {
      break choice_2;
    }
    r4 = peg$parsetable_caption_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_2
    if (r4===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = [r3,r4];
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r2;
  }
  function peg$parsetable_end_tag(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 192;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = [];
    for (;;) {
      choice_1: {
      r5 = peg$parsespace(silence);
      if (r5!==peg$FAILED) {
        break choice_1;
      }
      r5 = peg$parsecomment(silence);
      } // choice_1
      if (r5!==peg$FAILED) {
        r4.push(r5);
      } else {
        break;
      }
    }
    // sc <- r4
    // free r5
    p6 = peg$currPos;
    r5 = '';
    // startPos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a2(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parsepipe(silence);
    // p <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // b <- r8
    if (input.charCodeAt(peg$currPos) === 125) {
      r8 = "}";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c97);}
      r8 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a108(r4, r5, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetag_name(silence) {
    var p1,r2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 132;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p1 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[A-Za-z]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c98);}
      r2 = peg$FAILED;
      break seq_1;
    }
    for (;;) {
      r6 = peg$discardtag_name_chars(silence);
      if (r6===peg$FAILED) {
        break;
      }
    }
    // free r6
    r5 = true;
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r5
    r2 = true;
    } // seq_1
    if (r2!==peg$FAILED) {
      r2 = input.substring(p1, peg$currPos);
    } else {
      r2 = peg$FAILED;
    }
    // free p3
    // free p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$parsenewline(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 244;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    if (input.charCodeAt(peg$currPos) === 10) {
      r1 = "\n";
      peg$currPos += 1;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c49);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,2);
    if (r1 === "\r\n") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c50);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [78,boolParams & 0x3b83,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parsetemplate_param_text(silence, boolParams & ~0x8, param_templatedepth, param_preproc, param_th);
    // tpt <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a109(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenl_comment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 236;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsenewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsecomment_space(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardnl_comment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 237;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardnewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardcomment_space(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,p7,r8,p9,r10,r11,r12,p13,r14,r15;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [74,boolParams & 0x3b83,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsetemplate_param_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // name <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    seq_2: {
    p7 = peg$currPos;
    p9 = peg$currPos;
    r8 = '';
    // kEndPos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a110(r4);
    } else {
      r5 = peg$FAILED;
      break seq_2;
    }
    r10 = peg$discardoptionalSpaceToken(silence);
    if (r10===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 61) {
      r11 = "=";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c45);}
      r11 = peg$FAILED;
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    p13 = peg$currPos;
    r12 = '';
    // vStartPos <- r12
    if (r12!==peg$FAILED) {
      peg$savedPos = p13;
      r12 = peg$a111(r4, r8);
    } else {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r14 = peg$discardoptionalSpaceToken(silence);
    if (r14===peg$FAILED) {
      peg$currPos = p7;
      r5 = peg$FAILED;
      break seq_2;
    }
    r15 = peg$parsetemplate_param_value(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r15===peg$FAILED) {
      r15 = null;
    }
    // tpv <- r15
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a112(r4, r8, r12, r15);
    } else {
      r5 = null;
    }
    // free p7
    // val <- r5
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a113(r4, r5);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    p7 = peg$currPos;
    r1 = input.charAt(peg$currPos);
    if (/^[|}]/.test(r1)) {
      peg$currPos++;
      r1 = void 0;
      peg$currPos = p7;
      peg$savedPos = p3;
      r1 = peg$a114();
    } else {
      r1 = peg$FAILED;
    }
    // free p7
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsewikilink_preprocessor_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,r5,p6,r7,p8,r9,p10,p11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [254,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      p6 = peg$currPos;
      r5 = peg$FAILED;
      for (;;) {
        r7 = input.charAt(peg$currPos);
        if (/^[^<[{\n\r\t|!\]} &\-]/.test(r7)) {
          peg$currPos++;
          r5 = true;
        } else {
          r7 = peg$FAILED;
          if (!silence) {peg$fail(peg$c99);}
          break;
        }
      }
      // t <- r5
      if (r5!==peg$FAILED) {
        r5 = input.substring(p6, peg$currPos);
      } else {
        r5 = peg$FAILED;
      }
      // free r7
      // free p6
      r4 = r5;
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      seq_1: {
      p6 = peg$currPos;
      p8 = peg$currPos;
      r7 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r7 === peg$FAILED) {
        r7 = void 0;
      } else {
        r7 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_1;
      }
      // free p8
      choice_2: {
      r9 = peg$parsedirective(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        break choice_2;
      }
      p8 = peg$currPos;
      seq_2: {
      p10 = peg$currPos;
      p11 = peg$currPos;
      r12 = input.substr(peg$currPos,2);
      if (r12 === "]]") {
        peg$currPos += 2;
      } else {
        r12 = peg$FAILED;
      }
      if (r12 === peg$FAILED) {
        r12 = void 0;
      } else {
        r12 = peg$FAILED;
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_2;
      }
      // free p11
      r13 = input.charAt(peg$currPos);
      if (/^[^'~[{:;|=]/.test(r13)) {
        peg$currPos++;
      } else {
        r13 = peg$FAILED;
        if (!silence) {peg$fail(peg$c100);}
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_2;
      }
      r9 = true;
      } // seq_2
      if (r9!==peg$FAILED) {
        r9 = input.substring(p8, peg$currPos);
      } else {
        r9 = peg$FAILED;
      }
      // free p10
      // free p8
      } // choice_2
      // wr <- r9
      if (r9===peg$FAILED) {
        peg$currPos = p6;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r7,r9];
      } // seq_1
      // free p6
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // r <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a115(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsewikilink_content(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2,p3,p4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [110,boolParams & 0x39f7,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      p3 = peg$currPos;
      seq_1: {
      p4 = peg$currPos;
      r5 = peg$discardpipe(silence);
      if (r5===peg$FAILED) {
        r2 = peg$FAILED;
        break seq_1;
      }
      p7 = peg$currPos;
      r6 = '';
      // startPos <- r6
      if (r6!==peg$FAILED) {
        peg$savedPos = p7;
        r6 = peg$a26();
      } else {
        peg$currPos = p4;
        r2 = peg$FAILED;
        break seq_1;
      }
      r8 = peg$parselink_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r8===peg$FAILED) {
        r8 = null;
      }
      // lt <- r8
      r2 = true;
      } // seq_1
      if (r2!==peg$FAILED) {
        peg$savedPos = p3;
        r2 = peg$a116(r6, r8);
        r1.push(r2);
      } else {
        break;
      }
      // free p4
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsespace_or_nbsp(silence) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 220;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsespace(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parseunispace(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    seq_1: {
    p2 = peg$currPos;
    r3 = peg$parsehtmlentity(silence);
    // he <- r3
    if (r3===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r4 = peg$a117(r3);
    if (r4) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p2;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = [r3,r4];
    } // seq_1
    // free p2
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardend_of_word(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 217;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardeof(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    r1 = input.charAt(peg$currPos);
    if (/^[A-Za-z0-9_]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
    }
    if (r1 === peg$FAILED) {
      r1 = void 0;
    } else {
      r1 = peg$FAILED;
      peg$currPos = p2;
    }
    // free p2
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsespace_or_nbsp_or_dash(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 222;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsespace_or_nbsp(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 45) {
      r1 = "-";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c80);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parselang_variant_preproc(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,p7,p8,r9,r10,p11,r12,r13,p14,r15,r16,p17,r18,r19,r20,r21;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [88,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    // lv0 <- r4
    if (r4 === "-{") {
      peg$currPos += 2;
      peg$savedPos = p5;
      r4 = peg$a118();
    } else {
      if (!silence) {peg$fail(peg$c101);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_1: {
    p7 = peg$currPos;
    seq_2: {
    p8 = peg$currPos;
    peg$savedPos = peg$currPos;
    r9 = peg$a119(r4);
    if (r9) {
      r9 = void 0;
    } else {
      r9 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_2;
    }
    r10 = peg$parseopt_lang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // ff <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_2;
    }
    r6 = true;
    } // seq_2
    if (r6!==peg$FAILED) {
      peg$savedPos = p7;
      r6 = peg$a120(r4, r10);
      break choice_1;
    }
    // free p8
    p8 = peg$currPos;
    seq_3: {
    p11 = peg$currPos;
    peg$savedPos = peg$currPos;
    r12 = peg$a121(r4);
    if (r12) {
      r12 = void 0;
    } else {
      r12 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_3;
    }
    r6 = true;
    } // seq_3
    if (r6!==peg$FAILED) {
      peg$savedPos = p8;
      r6 = peg$a122(r4);
    }
    // free p11
    } // choice_1
    // f <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    choice_2: {
    p11 = peg$currPos;
    seq_4: {
    p14 = peg$currPos;
    peg$savedPos = peg$currPos;
    r15 = peg$a123(r4, r6);
    if (r15) {
      r15 = void 0;
    } else {
      r15 = peg$FAILED;
      r13 = peg$FAILED;
      break seq_4;
    }
    r16 = peg$parselang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lv <- r16
    if (r16===peg$FAILED) {
      peg$currPos = p14;
      r13 = peg$FAILED;
      break seq_4;
    }
    r13 = true;
    } // seq_4
    if (r13!==peg$FAILED) {
      peg$savedPos = p11;
      r13 = peg$a124(r4, r6, r16);
      break choice_2;
    }
    // free p14
    p14 = peg$currPos;
    seq_5: {
    p17 = peg$currPos;
    peg$savedPos = peg$currPos;
    r18 = peg$a125(r4, r6);
    if (r18) {
      r18 = void 0;
    } else {
      r18 = peg$FAILED;
      r13 = peg$FAILED;
      break seq_5;
    }
    r19 = peg$parselang_variant_option_list(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lv <- r19
    if (r19===peg$FAILED) {
      peg$currPos = p17;
      r13 = peg$FAILED;
      break seq_5;
    }
    r13 = true;
    } // seq_5
    if (r13!==peg$FAILED) {
      peg$savedPos = p14;
      r13 = peg$a126(r4, r6, r19);
    }
    // free p17
    } // choice_2
    // ts <- r13
    if (r13===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r20 = peg$discardinline_breaks(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r20===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p17 = peg$currPos;
    r21 = input.substr(peg$currPos,2);
    // lv1 <- r21
    if (r21 === "}-") {
      peg$currPos += 2;
      peg$savedPos = p17;
      r21 = peg$a127(r4, r6, r13);
    } else {
      if (!silence) {peg$fail(peg$c102);}
      r21 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a128(r4, r6, r13, r21);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsebroken_lang_variant(silence, param_preproc) {
    var r1,p2,p3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [84,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,2);
    // r <- r4
    if (r4 === "-{") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c101);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a129(r4, param_preproc);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$discardlist_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 163;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[*#:;]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c103);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parselist_char(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 162;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[*#:;]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c103);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseinlineline_break_on_colon(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [164,boolParams & 0x2bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parseinlineline(silence, boolParams | 0x1000, param_templatedepth, param_preproc, param_th);
    // ill <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a130(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardcomment_space_eolf(silence) {
    var p1,r2,r3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 251;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    seq_1: {
    p1 = peg$currPos;
    for (;;) {
      choice_1: {
      r4 = peg$FAILED;
      for (;;) {
        r5 = peg$discardspace(silence);
        if (r5!==peg$FAILED) {
          r4 = true;
        } else {
          break;
        }
      }
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      // free r5
      r4 = peg$discardcomment(silence);
      } // choice_1
      if (r4===peg$FAILED) {
        break;
      }
    }
    // free r4
    r3 = true;
    if (r3===peg$FAILED) {
      r2 = peg$FAILED;
      break seq_1;
    }
    // free r3
    r3 = peg$discardeolf(silence);
    if (r3===peg$FAILED) {
      peg$currPos = p1;
      r2 = peg$FAILED;
      break seq_1;
    }
    r2 = true;
    } // seq_1
    // free r2,p1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r2,
      };
  
    }
    return r2;
  }
  function peg$discardempty_line_with_comments(silence) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,r10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 233;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsesol_prefix(silence);
    // sp <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r5 = '';
    // p <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a75(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      seq_2: {
      p9 = peg$currPos;
      r10 = [];
      for (;;) {
        r11 = peg$parsespace(silence);
        if (r11!==peg$FAILED) {
          r10.push(r11);
        } else {
          break;
        }
      }
      // free r11
      r11 = peg$parsecomment(silence);
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r12 = [];
      for (;;) {
        choice_1: {
        r13 = peg$parsespace(silence);
        if (r13!==peg$FAILED) {
          break choice_1;
        }
        r13 = peg$parsecomment(silence);
        } // choice_1
        if (r13!==peg$FAILED) {
          r12.push(r13);
        } else {
          break;
        }
      }
      // free r13
      r13 = peg$parsenewline(silence);
      if (r13===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = [r10,r11,r12,r13];
      } // seq_2
      if (r8!==peg$FAILED) {
        r7.push(r8);
      } else {
        break;
      }
      // free p9
    }
    if (r7.length === 0) {
      r7 = peg$FAILED;
    }
    // c <- r7
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a76(r4, r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardsol_prefix(silence) {
    var r1,p2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 231;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardnewlineToken(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    p2 = peg$currPos;
    peg$savedPos = peg$currPos;
    r1 = peg$a77();
    if (r1) {
      r1 = void 0;
      peg$savedPos = p2;
      r1 = peg$a78();
    } else {
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardcomment_or_includes(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [227,boolParams & 0x13af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    for (;;) {
      choice_1: {
      r2 = peg$discardcomment(silence);
      if (r2!==peg$FAILED) {
        break choice_1;
      }
      r2 = peg$discardinclude_limits(silence, boolParams | 0x2000, param_templatedepth, param_preproc, param_th);
      } // choice_1
      if (r2===peg$FAILED) {
        break;
      }
    }
    // free r2
    r1 = true;
    // free r1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_heading_tags(silence, boolParams, param_templatedepth, param_preproc) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [186,boolParams & 0x3bff,param_templatedepth,param_preproc.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parsetable_heading_tags_parameterized(silence, boolParams, param_templatedepth, param_preproc, new peg$Reference(true));
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
    }
    return r1;
  }
  function peg$parsetable_row_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [178,boolParams & 0x3bef,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*tableDataBlock*/(boolParams & 0x1) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r6 = peg$FAILED;
    for (;;) {
      if (input.charCodeAt(peg$currPos) === 45) {
        r8 = "-";
        peg$currPos += 1;
        r6 = true;
      } else {
        if (!silence) {peg$fail(peg$c80);}
        r8 = peg$FAILED;
        break;
      }
    }
    // dashes <- r6
    if (r6!==peg$FAILED) {
      r6 = input.substring(p7, peg$currPos);
    } else {
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r8
    // free p7
    choice_1: {
    r8 = peg$parsetable_attributes(silence, boolParams & ~0x10, param_templatedepth, param_preproc, param_th);
    if (r8!==peg$FAILED) {
      break choice_1;
    }
    peg$savedPos = peg$currPos;
    r8 = peg$a131(r5, r6);
    if (r8) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
    }
    } // choice_1
    // a <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r9 = '';
    // tagEndPos <- r9
    if (r9!==peg$FAILED) {
      peg$savedPos = p7;
      r9 = peg$a132(r5, r6, r8);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a133(r5, r6, r8, r9);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_data_tags(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,r9,r10;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [182,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*tableDataBlock*/(boolParams & 0x1) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r7 = input.charAt(peg$currPos);
    if (/^[+\-]/.test(r7)) {
      peg$currPos++;
    } else {
      r7 = peg$FAILED;
    }
    if (r7 === peg$FAILED) {
      r7 = void 0;
    } else {
      r7 = peg$FAILED;
      peg$currPos = p6;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r8 = peg$parsetable_data_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // td <- r8
    if (r8===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    r9 = '';
    // tagEndPos <- r9
    if (r9!==peg$FAILED) {
      peg$savedPos = p6;
      r9 = peg$a134(r5, r8);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = peg$parsetds(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // tds <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a135(r5, r8, r9, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_caption_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7,r8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [176,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (!(/*tableDataBlock*/(boolParams & 0x1) !== 0)) {
      r4 = void 0;
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsepipe(silence);
    // p <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 43) {
      r6 = "+";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c104);}
      r6 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r7 = null;
    }
    // args <- r7
    p9 = peg$currPos;
    r8 = '';
    // tagEndPos <- r8
    if (r8!==peg$FAILED) {
      peg$savedPos = p9;
      r8 = peg$a136(r5, r7);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r10 = [];
    for (;;) {
      r11 = peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11!==peg$FAILED) {
        r10.push(r11);
      } else {
        break;
      }
    }
    // c <- r10
    // free r11
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a137(r5, r7, r8, r10);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardtag_name_chars(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 131;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[^\t\n\x0B \/>\0]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c105);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [80,boolParams & 0x3b8b,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parsenested_block(silence, (boolParams & ~0x54) | 0x20, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      r4 = peg$parsenewlineToken(silence);
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // il <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a138(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsecomment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 234;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$parsecomment(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$parsespace(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardcomment_space(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 235;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = peg$discardcomment(silence);
    if (r1!==peg$FAILED) {
      break choice_1;
    }
    r1 = peg$discardspace(silence);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parsetemplate_param_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,p5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [76,boolParams & 0x3b83,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    choice_1: {
    r3 = peg$parsetemplate_param_text(silence, boolParams | 0x8, param_templatedepth, param_preproc, param_th);
    if (r3!==peg$FAILED) {
      break choice_1;
    }
    p4 = peg$currPos;
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      r3 = "=";
      peg$currPos += 1;
      r3 = void 0;
      peg$currPos = p5;
      peg$savedPos = p4;
      r3 = peg$a139();
    } else {
      r3 = peg$FAILED;
    }
    // free p5
    } // choice_1
    // tpt <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a140(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselink_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [118,boolParams & 0x39f7,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parselink_text_parameterized(silence, (boolParams & ~0x8) | 0x200, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parseunispace(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 218;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = input.charAt(peg$currPos);
    if (/^[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/.test(r1)) {
      peg$currPos++;
    } else {
      r1 = peg$FAILED;
      if (!silence) {peg$fail(peg$c47);}
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$parseopt_lang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,p5,r6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [90,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    p4 = peg$currPos;
    seq_1: {
    p5 = peg$currPos;
    r6 = peg$parselang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // ff <- r6
    if (r6===peg$FAILED) {
      r3 = peg$FAILED;
      break seq_1;
    }
    if (input.charCodeAt(peg$currPos) === 124) {
      r7 = "|";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c13);}
      r7 = peg$FAILED;
      peg$currPos = p5;
      r3 = peg$FAILED;
      break seq_1;
    }
    r3 = true;
    } // seq_1
    if (r3!==peg$FAILED) {
      peg$savedPos = p4;
      r3 = peg$a141(r6);
    } else {
      r3 = null;
    }
    // free p5
    // f <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a142(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [104,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      r4 = peg$parseinlineline(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      if (input.charCodeAt(peg$currPos) === 124) {
        r4 = "|";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c13);}
        r4 = peg$FAILED;
      }
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    // tokens <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a143(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_option_list(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,p8,r9,r10,r11,p12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [98,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parselang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // o <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = [];
    for (;;) {
      p7 = peg$currPos;
      seq_2: {
      p8 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        r9 = ";";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c54);}
        r9 = peg$FAILED;
        r6 = peg$FAILED;
        break seq_2;
      }
      r10 = peg$parselang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // oo <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p8;
        r6 = peg$FAILED;
        break seq_2;
      }
      r6 = true;
      } // seq_2
      if (r6!==peg$FAILED) {
        peg$savedPos = p7;
        r6 = peg$a144(r4, r10);
        r5.push(r6);
      } else {
        break;
      }
      // free p8
    }
    // rest <- r5
    // free r6
    seq_3: {
    p8 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      r11 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c54);}
      r11 = peg$FAILED;
      r6 = peg$FAILED;
      break seq_3;
    }
    p12 = peg$currPos;
    for (;;) {
      r14 = peg$discardspace_or_newline(silence);
      if (r14===peg$FAILED) {
        break;
      }
    }
    // free r14
    r13 = true;
    if (r13!==peg$FAILED) {
      r13 = input.substring(p12, peg$currPos);
    } else {
      r13 = peg$FAILED;
      peg$currPos = p8;
      r6 = peg$FAILED;
      break seq_3;
    }
    // free p12
    r6 = [r11,r13];
    } // seq_3
    if (r6===peg$FAILED) {
      r6 = null;
    }
    // free p8
    // tr <- r6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a145(r4, r5, r6);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    r14 = peg$parselang_variant_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lvtext <- r14
    r1 = r14;
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a146(r14);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardcomment(silence) {
    var r1,p2,p3,r4,r5,p6,r7,p8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 37;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.substr(peg$currPos,4);
    if (r4 === "<!--") {
      peg$currPos += 4;
    } else {
      if (!silence) {peg$fail(peg$c10);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      seq_2: {
      p8 = peg$currPos;
      p9 = peg$currPos;
      r10 = input.substr(peg$currPos,3);
      if (r10 === "-->") {
        peg$currPos += 3;
      } else {
        r10 = peg$FAILED;
      }
      if (r10 === peg$FAILED) {
        r10 = void 0;
      } else {
        r10 = peg$FAILED;
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      // free p9
      if (peg$currPos < input.length) {
        r11 = input.charAt(peg$currPos++);
      } else {
        r11 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
        peg$currPos = p8;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7===peg$FAILED) {
        break;
      }
      // free p8
    }
    // free r7
    r5 = true;
    // c <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    choice_1: {
    r7 = input.substr(peg$currPos,3);
    if (r7 === "-->") {
      peg$currPos += 3;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c12);}
      r7 = peg$FAILED;
    }
    r7 = peg$discardeof(silence);
    } // choice_1
    if (r7===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a16(r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardinclude_limits(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,p6,r7,r8,r9,p10,r11,r12,r13;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [239,boolParams & 0x33af,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 60) {
      r7 = "<";
      peg$currPos += 1;
    } else {
      r7 = peg$FAILED;
      r5 = peg$FAILED;
      break seq_2;
    }
    if (input.charCodeAt(peg$currPos) === 47) {
      r8 = "/";
      peg$currPos += 1;
    } else {
      r8 = peg$FAILED;
      r8 = null;
    }
    p10 = peg$currPos;
    r9 = peg$FAILED;
    for (;;) {
      r11 = input.charAt(peg$currPos);
      if (/^[oyinclude]/i.test(r11)) {
        peg$currPos++;
        r9 = true;
      } else {
        r11 = peg$FAILED;
        break;
      }
    }
    // n <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p10, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r11
    // free p10
    peg$savedPos = peg$currPos;
    r11 = peg$a61(r9);
    if (r11) {
      r11 = void 0;
    } else {
      r11 = peg$FAILED;
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    if (r5!==peg$FAILED) {
      r5 = void 0;
      peg$currPos = p4;
    } else {
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    // free p4
    r12 = peg$parsexmlish_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // il <- r12
    if (r12===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r13 = peg$a62(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    if (r13) {
      r13 = void 0;
    } else {
      r13 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a63(r12, /*sol_il*/(boolParams & 0x2000) !== 0);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_heading_tags_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,r7,p8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [188,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 33) {
      r4 = "!";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c106);}
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parsetable_heading_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // thTag <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = [];
    for (;;) {
      p8 = peg$currPos;
      seq_2: {
      p9 = peg$currPos;
      choice_1: {
      r10 = input.substr(peg$currPos,2);
      if (r10 === "!!") {
        peg$currPos += 2;
        break choice_1;
      } else {
        if (!silence) {peg$fail(peg$c107);}
        r10 = peg$FAILED;
      }
      r10 = peg$parsepipe_pipe(silence);
      } // choice_1
      // pp <- r10
      if (r10===peg$FAILED) {
        r7 = peg$FAILED;
        break seq_2;
      }
      r11 = peg$parsetable_heading_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // tht <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r7 = peg$FAILED;
        break seq_2;
      }
      r7 = true;
      } // seq_2
      if (r7!==peg$FAILED) {
        peg$savedPos = p8;
        r7 = peg$a147(r5, r10, r11);
        r6.push(r7);
      } else {
        break;
      }
      // free p9
    }
    // thTags <- r6
    // free r7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a148(r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_data_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6,r7,r8,r9;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [184,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 125) {
      r5 = "}";
      peg$currPos += 1;
    } else {
      r5 = peg$FAILED;
    }
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r6===peg$FAILED) {
      r6 = null;
    }
    // arg <- r6
    p4 = peg$currPos;
    r7 = '';
    // tagEndPos <- r7
    if (r7!==peg$FAILED) {
      peg$savedPos = p4;
      r7 = peg$a149(r6);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r8 = [];
    for (;;) {
      r9 = peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9!==peg$FAILED) {
        r8.push(r9);
      } else {
        break;
      }
    }
    // td <- r8
    // free r9
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a150(r6, r7, r8);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetds(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,r2,p3,p4,r5,p6,p7,r8,p9,r10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [180,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = [];
    for (;;) {
      p3 = peg$currPos;
      seq_1: {
      p4 = peg$currPos;
      choice_1: {
      r5 = peg$parsepipe_pipe(silence);
      if (r5!==peg$FAILED) {
        break choice_1;
      }
      p6 = peg$currPos;
      seq_2: {
      p7 = peg$currPos;
      r8 = peg$parsepipe(silence);
      // p <- r8
      if (r8===peg$FAILED) {
        r5 = peg$FAILED;
        break seq_2;
      }
      p9 = peg$currPos;
      r10 = peg$discardrow_syntax_table_args(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        r10 = void 0;
        peg$currPos = p9;
      } else {
        peg$currPos = p7;
        r5 = peg$FAILED;
        break seq_2;
      }
      // free p9
      r5 = true;
      } // seq_2
      if (r5!==peg$FAILED) {
        peg$savedPos = p6;
        r5 = peg$a151(r8);
      }
      // free p7
      } // choice_1
      // pp <- r5
      if (r5===peg$FAILED) {
        r2 = peg$FAILED;
        break seq_1;
      }
      r11 = peg$parsetable_data_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // tdt <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p4;
        r2 = peg$FAILED;
        break seq_1;
      }
      r2 = true;
      } // seq_1
      if (r2!==peg$FAILED) {
        peg$savedPos = p3;
        r2 = peg$a152(r5, r11);
        r1.push(r2);
      } else {
        break;
      }
      // free p4
    }
    // free r2
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,p6,r7,r8,p9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [16,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    seq_2: {
    p6 = peg$currPos;
    r7 = peg$discardsol(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r7===peg$FAILED) {
      r5 = peg$FAILED;
      break seq_2;
    }
    seq_3: {
    p9 = peg$currPos;
    for (;;) {
      r11 = peg$discardspace(true);
      if (r11===peg$FAILED) {
        break;
      }
    }
    // free r11
    r10 = true;
    if (r10===peg$FAILED) {
      r8 = peg$FAILED;
      break seq_3;
    }
    // free r10
    r10 = peg$discardsol(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10===peg$FAILED) {
      peg$currPos = p9;
      r8 = peg$FAILED;
      break seq_3;
    }
    r8 = true;
    } // seq_3
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // free p9
    for (;;) {
      r12 = peg$discardspace(true);
      if (r12===peg$FAILED) {
        break;
      }
    }
    // free r12
    r11 = true;
    if (r11===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    // free r11
    choice_1: {
    r11 = peg$discardpipe(true);
    if (r11!==peg$FAILED) {
      break choice_1;
    }
    if (input.charCodeAt(peg$currPos) === 33) {
      r11 = "!";
      peg$currPos += 1;
    } else {
      r11 = peg$FAILED;
    }
    } // choice_1
    if (r11===peg$FAILED) {
      peg$currPos = p6;
      r5 = peg$FAILED;
      break seq_2;
    }
    r5 = true;
    } // seq_2
    // free p6
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r12 = peg$parsenested_block(silence, boolParams | 0x1, param_templatedepth, param_preproc, param_th);
    // b <- r12
    if (r12===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a153(r12);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenested_block(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,p4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [14,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p4 = peg$currPos;
    r5 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5 === peg$FAILED) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p4;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p4
    r6 = peg$parseblock(silence, boolParams, param_templatedepth, param_th, param_preproc);
    // b <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a154(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselink_text_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,r4,p5,r6,r7,p8,r9,r10,r11,r12,r13,p14,r15,p16,p17;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [120,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = [];
    for (;;) {
      choice_1: {
      seq_1: {
      p5 = peg$currPos;
      r6 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r6===peg$FAILED) {
        r4 = peg$FAILED;
        break seq_1;
      }
      choice_2: {
      r7 = peg$parseheading(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      r7 = peg$parsehr(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r7!==peg$FAILED) {
        break choice_2;
      }
      r7 = peg$parsefull_table_in_link_caption(silence, boolParams, param_templatedepth, param_preproc, param_th);
      } // choice_2
      if (r7===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_1;
      }
      r4 = [r6,r7];
      } // seq_1
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      // free p5
      r4 = peg$parseurltext(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r4!==peg$FAILED) {
        break choice_1;
      }
      seq_2: {
      p5 = peg$currPos;
      p8 = peg$currPos;
      r9 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r9 === peg$FAILED) {
        r9 = void 0;
      } else {
        r9 = peg$FAILED;
        peg$currPos = p8;
        r4 = peg$FAILED;
        break seq_2;
      }
      // free p8
      choice_3: {
      r10 = peg$parseinline_element(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r10!==peg$FAILED) {
        break choice_3;
      }
      seq_3: {
      p8 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        r11 = "[";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c42);}
        r11 = peg$FAILED;
        r10 = peg$FAILED;
        break seq_3;
      }
      r12 = [];
      for (;;) {
        r13 = input.charAt(peg$currPos);
        if (/^[^\-'<~[{\n\r:;\]}|!=]/.test(r13)) {
          peg$currPos++;
          r12.push(r13);
        } else {
          r13 = peg$FAILED;
          if (!silence) {peg$fail(peg$c64);}
          break;
        }
      }
      if (r12.length === 0) {
        r12 = peg$FAILED;
      }
      if (r12===peg$FAILED) {
        peg$currPos = p8;
        r10 = peg$FAILED;
        break seq_3;
      }
      // free r13
      if (input.charCodeAt(peg$currPos) === 93) {
        r13 = "]";
        peg$currPos += 1;
      } else {
        if (!silence) {peg$fail(peg$c44);}
        r13 = peg$FAILED;
        peg$currPos = p8;
        r10 = peg$FAILED;
        break seq_3;
      }
      p14 = peg$currPos;
      p16 = peg$currPos;
      choice_4: {
      p17 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 93) {
        r15 = "]";
        peg$currPos += 1;
      } else {
        r15 = peg$FAILED;
      }
      if (r15 === peg$FAILED) {
        r15 = void 0;
        break choice_4;
      } else {
        r15 = peg$FAILED;
        peg$currPos = p17;
      }
      // free p17
      r15 = input.substr(peg$currPos,2);
      if (r15 === "]]") {
        peg$currPos += 2;
      } else {
        r15 = peg$FAILED;
      }
      } // choice_4
      if (r15!==peg$FAILED) {
        r15 = void 0;
        peg$currPos = p16;
        r15 = input.substring(p14, peg$currPos);
      } else {
        r15 = peg$FAILED;
        peg$currPos = p8;
        r10 = peg$FAILED;
        break seq_3;
      }
      // free p16
      // free p14
      r10 = [r11,r12,r13,r15];
      } // seq_3
      if (r10!==peg$FAILED) {
        break choice_3;
      }
      // free p8
      if (peg$currPos < input.length) {
        r10 = input.charAt(peg$currPos++);
      } else {
        r10 = peg$FAILED;
        if (!silence) {peg$fail(peg$c11);}
      }
      } // choice_3
      // r <- r10
      if (r10===peg$FAILED) {
        peg$currPos = p5;
        r4 = peg$FAILED;
        break seq_2;
      }
      r4 = [r9,r10];
      } // seq_2
      // free p5
      } // choice_1
      if (r4!==peg$FAILED) {
        r3.push(r4);
      } else {
        break;
      }
    }
    if (r3.length === 0) {
      r3 = peg$FAILED;
    }
    // c <- r3
    // free r4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a155(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,r9,r10,r11,r12;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [92,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    for (;;) {
      r6 = peg$discardspace_or_newline(silence);
      if (r6===peg$FAILED) {
        break;
      }
    }
    // free r6
    r4 = true;
    // sp1 <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parselang_variant_flag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // f <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace_or_newline(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    // sp2 <- r7
    if (r7!==peg$FAILED) {
      r7 = input.substring(p5, peg$currPos);
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    seq_2: {
    p5 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 59) {
      r9 = ";";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c54);}
      r9 = peg$FAILED;
      r8 = peg$FAILED;
      break seq_2;
    }
    r10 = peg$parselang_variant_flags(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10===peg$FAILED) {
      r10 = null;
    }
    r8 = [r9,r10];
    } // seq_2
    if (r8===peg$FAILED) {
      r8 = null;
    }
    // free p5
    // more <- r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a156(r4, r6, r7, r8);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    p5 = peg$currPos;
    for (;;) {
      r12 = peg$discardspace_or_newline(silence);
      if (r12===peg$FAILED) {
        break;
      }
    }
    // free r12
    r11 = true;
    // sp <- r11
    if (r11!==peg$FAILED) {
      r11 = input.substring(p5, peg$currPos);
    } else {
      r11 = peg$FAILED;
    }
    // free p5
    r1 = r11;
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a157(r11);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_option(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6,r7,r8,r9,r10,r11,p12,r13,r14,r15,r16,r17,r18,r19,r20;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [100,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    p5 = peg$currPos;
    for (;;) {
      r6 = peg$discardspace_or_newline(silence);
      if (r6===peg$FAILED) {
        break;
      }
    }
    // free r6
    r4 = true;
    // sp1 <- r4
    if (r4!==peg$FAILED) {
      r4 = input.substring(p5, peg$currPos);
    } else {
      r4 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    r6 = peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lang <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    for (;;) {
      r8 = peg$discardspace_or_newline(silence);
      if (r8===peg$FAILED) {
        break;
      }
    }
    // free r8
    r7 = true;
    // sp2 <- r7
    if (r7!==peg$FAILED) {
      r7 = input.substring(p5, peg$currPos);
    } else {
      r7 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    if (input.charCodeAt(peg$currPos) === 58) {
      r8 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c68);}
      r8 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p5 = peg$currPos;
    for (;;) {
      r10 = peg$discardspace_or_newline(silence);
      if (r10===peg$FAILED) {
        break;
      }
    }
    // free r10
    r9 = true;
    // sp3 <- r9
    if (r9!==peg$FAILED) {
      r9 = input.substring(p5, peg$currPos);
    } else {
      r9 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p5
    choice_2: {
    r10 = peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r10!==peg$FAILED) {
      break choice_2;
    }
    r10 = peg$parselang_variant_text_no_semi(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_2
    // lvtext <- r10
    if (r10===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a158(r4, r6, r7, r9, r10);
      break choice_1;
    }
    // free p3
    p3 = peg$currPos;
    seq_2: {
    p5 = peg$currPos;
    p12 = peg$currPos;
    for (;;) {
      r13 = peg$discardspace_or_newline(silence);
      if (r13===peg$FAILED) {
        break;
      }
    }
    // free r13
    r11 = true;
    // sp1 <- r11
    if (r11!==peg$FAILED) {
      r11 = input.substring(p12, peg$currPos);
    } else {
      r11 = peg$FAILED;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    choice_3: {
    r13 = peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r13!==peg$FAILED) {
      break choice_3;
    }
    r13 = peg$parselang_variant_text_no_semi_or_arrow(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_3
    // from <- r13
    if (r13===peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    r14 = input.substr(peg$currPos,2);
    if (r14 === "=>") {
      peg$currPos += 2;
    } else {
      if (!silence) {peg$fail(peg$c108);}
      r14 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    p12 = peg$currPos;
    for (;;) {
      r16 = peg$discardspace_or_newline(silence);
      if (r16===peg$FAILED) {
        break;
      }
    }
    // free r16
    r15 = true;
    // sp2 <- r15
    if (r15!==peg$FAILED) {
      r15 = input.substring(p12, peg$currPos);
    } else {
      r15 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    r16 = peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // lang <- r16
    if (r16===peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    p12 = peg$currPos;
    for (;;) {
      r18 = peg$discardspace_or_newline(silence);
      if (r18===peg$FAILED) {
        break;
      }
    }
    // free r18
    r17 = true;
    // sp3 <- r17
    if (r17!==peg$FAILED) {
      r17 = input.substring(p12, peg$currPos);
    } else {
      r17 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    if (input.charCodeAt(peg$currPos) === 58) {
      r18 = ":";
      peg$currPos += 1;
    } else {
      if (!silence) {peg$fail(peg$c68);}
      r18 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    p12 = peg$currPos;
    for (;;) {
      r20 = peg$discardspace_or_newline(silence);
      if (r20===peg$FAILED) {
        break;
      }
    }
    // free r20
    r19 = true;
    // sp4 <- r19
    if (r19!==peg$FAILED) {
      r19 = input.substring(p12, peg$currPos);
    } else {
      r19 = peg$FAILED;
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    // free p12
    choice_4: {
    r20 = peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r20!==peg$FAILED) {
      break choice_4;
    }
    r20 = peg$parselang_variant_text_no_semi(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_4
    // to <- r20
    if (r20===peg$FAILED) {
      peg$currPos = p5;
      r1 = peg$FAILED;
      break seq_2;
    }
    r1 = true;
    } // seq_2
    if (r1!==peg$FAILED) {
      peg$savedPos = p3;
      r1 = peg$a159(r11, r13, r15, r16, r17, r19, r20);
    }
    // free p5
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsetable_heading_tag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7,r8,p9,p10,r11;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [190,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parserow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4===peg$FAILED) {
      r4 = null;
    }
    // arg <- r4
    p6 = peg$currPos;
    r5 = '';
    // tagEndPos <- r5
    if (r5!==peg$FAILED) {
      peg$savedPos = p6;
      r5 = peg$a149(r4);
    } else {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      p9 = peg$currPos;
      seq_2: {
      p10 = peg$currPos;
      r11 = peg$parsenested_block_in_table(silence, boolParams, param_templatedepth, param_preproc, param_th);
      // d <- r11
      if (r11===peg$FAILED) {
        peg$currPos = p10;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = true;
      } // seq_2
      if (r8!==peg$FAILED) {
        peg$savedPos = p9;
        r8 = peg$a160(r4, r5, param_th, r11);
        r7.push(r8);
      } else {
        break;
      }
      // free p10
    }
    // c <- r7
    // free r8
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a161(r4, r5, r7);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsepipe_pipe(silence) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = 274;
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
          
          return cached.result;
        }
      }
      
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    r1 = input.substr(peg$currPos,2);
    if (r1 === "||") {
      peg$currPos += 2;
      break choice_1;
    } else {
      if (!silence) {peg$fail(peg$c109);}
      r1 = peg$FAILED;
    }
    r1 = input.substr(peg$currPos,10);
    if (r1 === "{{!}}{{!}}") {
      peg$currPos += 10;
    } else {
      if (!silence) {peg$fail(peg$c110);}
      r1 = peg$FAILED;
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
  
    }
    return r1;
  }
  function peg$discardrow_syntax_table_args(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6,p7,r8;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [195,boolParams & 0x3bbf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsetable_attributes(silence, boolParams | 0x40, param_templatedepth, param_preproc, param_th);
    // as <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$parseoptional_spaces(silence);
    // s <- r5
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsepipe(silence);
    // p <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    p7 = peg$currPos;
    r8 = peg$discardpipe(true);
    if (r8 === peg$FAILED) {
      r8 = void 0;
    } else {
      r8 = peg$FAILED;
      peg$currPos = p7;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p7
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a9(r4, r5, r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsefull_table_in_link_caption(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,p5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [166,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    choice_1: {
    p5 = peg$currPos;
    r4 = peg$discardinline_breaks(true, boolParams, param_templatedepth, param_preproc, param_th);
    if (r4 === peg$FAILED) {
      r4 = void 0;
      break choice_1;
    } else {
      r4 = peg$FAILED;
      peg$currPos = p5;
    }
    // free p5
    p5 = peg$currPos;
    r4 = input.substr(peg$currPos,5);
    if (r4 === "{{!}}") {
      peg$currPos += 5;
      r4 = void 0;
      peg$currPos = p5;
    } else {
      r4 = peg$FAILED;
    }
    // free p5
    } // choice_1
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parsefull_table_in_link_caption_parameterized(silence, (boolParams & ~0x200) | 0x10, param_templatedepth, param_preproc, param_th);
    // r <- r6
    if (r6===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a162(r6);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_flag(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,r5,p6,r7,p8,r9,p10,p11,r12,r13,r14;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [94,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    r3 = input.charAt(peg$currPos);
    // f <- r3
    if (/^[\-+A-Z]/.test(r3)) {
      peg$currPos++;
    } else {
      r3 = peg$FAILED;
      if (!silence) {peg$fail(peg$c111);}
    }
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a163(r3);
      break choice_1;
    }
    p4 = peg$currPos;
    r5 = peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // v <- r5
    r1 = r5;
    if (r1!==peg$FAILED) {
      peg$savedPos = p4;
      r1 = peg$a164(r5);
      break choice_1;
    }
    p6 = peg$currPos;
    p8 = peg$currPos;
    r7 = peg$FAILED;
    for (;;) {
      seq_1: {
      p10 = peg$currPos;
      p11 = peg$currPos;
      r12 = peg$discardspace_or_newline(true);
      if (r12 === peg$FAILED) {
        r12 = void 0;
      } else {
        r12 = peg$FAILED;
        peg$currPos = p11;
        r9 = peg$FAILED;
        break seq_1;
      }
      // free p11
      p11 = peg$currPos;
      r13 = peg$discardnowiki(true, boolParams, param_templatedepth, param_preproc, param_th);
      if (r13 === peg$FAILED) {
        r13 = void 0;
      } else {
        r13 = peg$FAILED;
        peg$currPos = p11;
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_1;
      }
      // free p11
      r14 = input.charAt(peg$currPos);
      if (/^[^{}|;]/.test(r14)) {
        peg$currPos++;
      } else {
        r14 = peg$FAILED;
        if (!silence) {peg$fail(peg$c112);}
        peg$currPos = p10;
        r9 = peg$FAILED;
        break seq_1;
      }
      r9 = true;
      } // seq_1
      if (r9!==peg$FAILED) {
        r7 = true;
      } else {
        break;
      }
      // free p10
    }
    // b <- r7
    if (r7!==peg$FAILED) {
      r7 = input.substring(p8, peg$currPos);
    } else {
      r7 = peg$FAILED;
    }
    // free r9
    // free p8
    r1 = r7;
    if (r1!==peg$FAILED) {
      peg$savedPos = p6;
      r1 = peg$a165(r7);
    }
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_name(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,r6;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [96,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    choice_1: {
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = input.charAt(peg$currPos);
    if (/^[a-z]/.test(r4)) {
      peg$currPos++;
    } else {
      r4 = peg$FAILED;
      if (!silence) {peg$fail(peg$c113);}
      r1 = peg$FAILED;
      break seq_1;
    }
    r5 = peg$FAILED;
    for (;;) {
      r6 = input.charAt(peg$currPos);
      if (/^[\-a-z]/.test(r6)) {
        peg$currPos++;
        r5 = true;
      } else {
        r6 = peg$FAILED;
        if (!silence) {peg$fail(peg$c114);}
        break;
      }
    }
    if (r5===peg$FAILED) {
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free r6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      r1 = input.substring(p2, peg$currPos);
      break choice_1;
    } else {
      r1 = peg$FAILED;
    }
    // free p3
    // free p2
    r1 = peg$parsenowiki_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    } // choice_1
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_nowiki(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5,p6,r7;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [102,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parsenowiki_text(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // n <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    p6 = peg$currPos;
    for (;;) {
      r7 = peg$discardspace_or_newline(silence);
      if (r7===peg$FAILED) {
        break;
      }
    }
    // free r7
    r5 = true;
    // sp <- r5
    if (r5!==peg$FAILED) {
      r5 = input.substring(p6, peg$currPos);
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    // free p6
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a166(r4, r5);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_text_no_semi(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [106,boolParams & 0x3b7f,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parselang_variant_text(silence, boolParams | 0x80, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parselang_variant_text_no_semi_or_arrow(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [108,boolParams & 0x3a7f,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    r1 = peg$parselang_variant_text_no_semi(silence, boolParams | 0x100, param_templatedepth, param_preproc, param_th);
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsefull_table_in_link_caption_parameterized(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3,p4,r5,r6,r7,r8,p9,r10,r11,p12,r13,r14,r15,r16;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [168,boolParams & 0x3bff,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p4 = peg$currPos;
    r5 = peg$parsetable_start_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    if (r5===peg$FAILED) {
      r3 = peg$FAILED;
      break seq_1;
    }
    r6 = peg$parseoptionalNewlines(silence);
    if (r6===peg$FAILED) {
      peg$currPos = p4;
      r3 = peg$FAILED;
      break seq_1;
    }
    r7 = [];
    for (;;) {
      seq_2: {
      p9 = peg$currPos;
      r10 = [];
      for (;;) {
        seq_3: {
        p12 = peg$currPos;
        r13 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
        if (r13===peg$FAILED) {
          r11 = peg$FAILED;
          break seq_3;
        }
        choice_1: {
        r14 = peg$parsetable_content_line(silence, boolParams, param_templatedepth, param_preproc, param_th);
        if (r14!==peg$FAILED) {
          break choice_1;
        }
        r14 = peg$parsetplarg_or_template(silence, boolParams, param_templatedepth, param_th, param_preproc);
        } // choice_1
        if (r14===peg$FAILED) {
          peg$currPos = p12;
          r11 = peg$FAILED;
          break seq_3;
        }
        r15 = peg$parseoptionalNewlines(silence);
        if (r15===peg$FAILED) {
          peg$currPos = p12;
          r11 = peg$FAILED;
          break seq_3;
        }
        r11 = [r13,r14,r15];
        } // seq_3
        if (r11!==peg$FAILED) {
          r10.push(r11);
        } else {
          break;
        }
        // free p12
      }
      // free r11
      r11 = peg$parsesol(silence, boolParams, param_templatedepth, param_preproc, param_th);
      if (r11===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r16 = peg$parsetable_end_tag(silence);
      if (r16===peg$FAILED) {
        peg$currPos = p9;
        r8 = peg$FAILED;
        break seq_2;
      }
      r8 = [r10,r11,r16];
      } // seq_2
      if (r8!==peg$FAILED) {
        r7.push(r8);
      } else {
        break;
      }
      // free p9
    }
    if (r7.length === 0) {
      r7 = peg$FAILED;
    }
    if (r7===peg$FAILED) {
      peg$currPos = p4;
      r3 = peg$FAILED;
      break seq_1;
    }
    // free r8
    r3 = [r5,r6,r7];
    } // seq_1
    // tbl <- r3
    // free p4
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a167(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$discardnowiki(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [127,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$a168(r4);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a169(r4);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenowiki_text(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,r3;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [128,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    r3 = peg$parsenowiki(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r3
    r1 = r3;
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a170(r3);
    }
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }
  function peg$parsenowiki(silence, boolParams, param_templatedepth, param_preproc, param_th) {
    var r1,p2,p3,r4,r5;
    var checkCache = visitCounts[peg$currPos] > 20;
    var cached, bucket, key;
    if (checkCache) {
      key = [126,boolParams & 0x3baf,param_templatedepth,param_preproc.value,param_th.value].map(String).join(':');
      bucket = peg$currPos;
      if ( !peg$cache[bucket] ) {
        peg$cache[bucket] = {};
      } else {
        cached = peg$cache[bucket][key];
        if (cached) {
          peg$currPos = cached.nextPos;
                  if (cached.hasOwnProperty("$preproc")) param_preproc.value = cached.$preproc;
            if (cached.hasOwnProperty("$th")) param_th.value = cached.$th;
          return cached.result;
        }
      }
          var saved_preproc=param_preproc.value;
        var saved_th=param_th.value;
    } else {
      visitCounts[peg$currPos]++;
    }
    p2 = peg$currPos;
    seq_1: {
    p3 = peg$currPos;
    r4 = peg$parseextension_tag(silence, boolParams, param_templatedepth, param_preproc, param_th);
    // extToken <- r4
    if (r4===peg$FAILED) {
      r1 = peg$FAILED;
      break seq_1;
    }
    peg$savedPos = peg$currPos;
    r5 = peg$a168(r4);
    if (r5) {
      r5 = void 0;
    } else {
      r5 = peg$FAILED;
      peg$currPos = p3;
      r1 = peg$FAILED;
      break seq_1;
    }
    r1 = true;
    } // seq_1
    if (r1!==peg$FAILED) {
      peg$savedPos = p2;
      r1 = peg$a169(r4);
    }
    // free p3
    if (checkCache) {
      cached = peg$cache[bucket][key] = {
        nextPos: peg$currPos,
        result: r1,
      };
      if (saved_preproc !== param_preproc.value) cached.$preproc = param_preproc.value;
      if (saved_th !== param_th.value) cached.$th = param_th.value;
    }
    return r1;
  }

  // start

  if (options.stream) {
    switch (peg$startRule) {
      case '(DEFAULT)':
      case "start_async":
        return peg$streamstart_async(false, new peg$Reference(null));
        break;
      default:
        throw new Error(`Can't stream rule "${peg$startRule}".`);
    }
  } else {
    switch (peg$startRule) {
      case '(DEFAULT)':
      case "start":
        peg$result = peg$parsestart(false, new peg$Reference(null));
        break;
      
      case "table_start_tag":
        peg$result = peg$parsetable_start_tag(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "url":
        peg$result = peg$parseurl(false, new peg$Reference(null));
        break;
      
      case "row_syntax_table_args":
        peg$result = peg$parserow_syntax_table_args(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "table_attributes":
        peg$result = peg$parsetable_attributes(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "generic_newline_attributes":
        peg$result = peg$parsegeneric_newline_attributes(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      
      case "tplarg_or_template_or_bust":
        peg$result = peg$parsetplarg_or_template_or_bust(false, new peg$Reference(null));
        break;
      
      case "extlink":
        peg$result = peg$parseextlink(false, 0, 0, new peg$Reference(null), new peg$Reference(null));
        break;
      default:
        throw new Error(`Can't start parsing from rule "${peg$startRule}".`);
    }
  }

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$c0);
    }
    throw peg$buildParseException();
  }
}

return {
  SyntaxError:   peg$SyntaxError,
  DefaultTracer: peg$DefaultTracer,
  parse: peg$parse
};

})();
